<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Make layout responsive on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brookline Town Meeting Voting Analysis</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap">

    <!-- XLSX library for reading Excel files directly in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Plotly for interactive scatter plots in voter clustering -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        /* Basic reset to make sizing and spacing predictable */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --tm-coral: #F63049;
            --tm-rose: #D02752;
            --tm-plum: #8A244B;
            --tm-navy: #111F35;
            --tm-bg: #f6f3f5;
            --tm-line: #e5dde3;
            --tm-soft-navy: rgba(17, 31, 53, 0.08);
            --tm-soft-coral: rgba(246, 48, 73, 0.1);
            --tm-soft-rose: rgba(208, 39, 82, 0.12);
            --tm-soft-plum: rgba(138, 36, 75, 0.14);
            --tm-focus: rgba(246, 48, 73, 0.18);
        }

        /* Overall page styling */
        body {
            font-family: 'Varela Round', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--tm-bg);
            padding: 20px;
            color: var(--tm-navy);
        }

        /* Main centered card container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        /* Main title */
        h1 {
            color: var(--tm-navy);
            margin-bottom: 10px;
            font-size: 34px;
            font-weight: 800;
        }

        /* Subtitle text under title */
        .subtitle {
            color: var(--tm-plum);
            margin-bottom: 30px;
            font-size: 20px;
            font-weight: 700;
        }

        /* Tab bar container */
        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 16px;
        }

        /* Individual tab button */
        .tab {
            padding: 10px 16px;
            cursor: pointer;
            border: 2px solid var(--tm-line);
            border-radius: 999px;
            background: #fff;
            font-family: inherit;
            font-size: 15px;
            color: var(--tm-plum);
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: var(--tm-rose);
            border-color: rgba(246, 48, 73, 0.4);
            background-color: var(--tm-soft-coral);
        }

        /* Active tab styling */
        .tab.active {
            color: var(--tm-navy);
            border-color: rgba(246, 48, 73, 0.4);
            background-color: var(--tm-soft-coral);
            font-weight: 600;
        }

        .module-instruction {
            display: none;
            margin-bottom: 12px;
            color: var(--tm-plum);
            font-size: 14px;
            font-weight: 600;
        }

        /* Base hidden state for tab content */
        .tab-content {
            display: none;
        }

        /* Shown tab content */
        .tab-content.active {
            display: block;
        }

        /* Container for the “controls” row above the results */
        .controls {
            margin-bottom: 25px;
        }

        /* Layout for label + selects + checkboxes */
        .control-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-weight: 600;
            color: var(--tm-navy);
            font-size: 14px;
        }

        /* Styling for all <select> dropdowns */
        select {
            padding: 10px 15px;
            border: 2px solid var(--tm-line);
            border-radius: 8px;
            font-family: inherit;
            font-size: 15px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
            min-width: 300px;
        }

        option,
        optgroup {
            font-family: inherit;
        }

        select:hover {
            border-color: var(--tm-coral);
        }

        select:focus {
            outline: none;
            border-color: var(--tm-coral);
            box-shadow: 0 0 0 3px var(--tm-focus);
        }

        /* Checkbox + label container */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--tm-coral);
        }

        /* Grid layout used in “view by vote” (four columns of results) */
        .results {
            display: grid;
            grid-template-columns: repeat(4, minmax(300px, 1fr));
            gap: 20px;
        }

        /* Wrapper for the entire vote result area */
        .vote-results-container {
            width: 100%;
        }

        /* Base styling for each vote column (Yes/No/Abstain/No Vote) */
        .vote-column {
            background-color: #fbf8fa;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--tm-line);
        }

        .vote-column h3 {
            font-size: 18px;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
        }

        /* Article description box shown above vote results when in View by Vote */
        .article-description {
            background-color: var(--tm-soft-coral);
            border: 1px solid rgba(208, 39, 82, 0.35);
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.4;
        }

        .article-description h4 {
            margin-bottom: 6px;
            color: var(--tm-navy);
            font-size: 14px;
            font-weight: 600;
        }

        .article-meta {
            margin-bottom: 8px;
            color: var(--tm-plum);
            font-size: 13px;
            font-weight: 600;
        }

        .article-summary-line {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            color: var(--tm-plum);
            font-size: 13px;
            font-weight: 600;
        }

        .article-summary-primary {
            color: var(--tm-navy);
            font-size: 14px;
        }

        .article-summary-separator {
            color: var(--tm-rose);
        }

        /* Wrapper used in View by Member for title+description pairs */
        .article-item-with-desc {
            margin-bottom: 12px;
        }

        .article-title {
            padding: 8px 12px;
            background-color: white;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid var(--tm-line);
            font-weight: 600;
            color: var(--tm-navy);
        }

        .article-desc {
            padding: 6px 12px;
            margin-top: 4px;
            margin-left: 12px;
            background-color: var(--tm-soft-navy);
            border-radius: 4px;
            font-size: 13px;
            color: var(--tm-navy);
            font-style: italic;
            border-left: 3px solid var(--tm-plum);
        }

        .article-detail {
            border: 1px solid var(--tm-line);
            border-radius: 6px;
            background-color: white;
        }

        .article-title-toggle {
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .article-title-toggle::-webkit-details-marker {
            display: none;
        }

        .article-title-toggle::after {
            content: '+';
            color: var(--tm-rose);
            font-size: 16px;
            font-weight: 700;
            line-height: 1;
            margin-left: 12px;
        }

        .article-detail[open] .article-title-toggle::after {
            content: '-';
        }

        .article-detail-body {
            padding-bottom: 8px;
        }

        .article-vote-result {
            margin-left: 12px;
            margin-top: 4px;
            margin-bottom: 6px;
            color: var(--tm-plum);
            font-size: 13px;
            font-weight: 600;
        }

        .article-links {
            margin-top: 6px;
            margin-left: 12px;
            padding-left: 0;
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .article-links li {
            margin-bottom: 0;
            font-size: 13px;
            line-height: 1.35;
            display: inline-flex;
            align-items: center;
        }

        .article-links li:not(:last-child)::after {
            content: '•';
            margin-left: 8px;
            color: var(--tm-rose);
        }

        .article-links a {
            color: var(--tm-rose);
            text-decoration: underline;
        }

        .counted-vote-outcome {
            margin-top: 8px;
            margin-left: 12px;
            font-size: 13px;
            font-weight: 700;
            color: var(--tm-navy);
        }

        /* Color theming for the four vote types */
        .vote-column.yes h3 {
            background-color: var(--tm-soft-coral);
            color: var(--tm-navy);
        }

        .vote-column.no h3 {
            background-color: var(--tm-soft-rose);
            color: var(--tm-navy);
        }

        .vote-column.abstain h3 {
            background-color: var(--tm-soft-plum);
            color: var(--tm-navy);
        }

        .vote-column.novote h3 {
            background-color: var(--tm-soft-navy);
            color: var(--tm-navy);
        }

        /* Scrollable list of members or articles */
        .member-list,
        .article-list {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 5px;
        }

        /* Individual line items for members/articles */
        .member-item,
        .article-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            background-color: white;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid var(--tm-line);
            transition: all 0.2s ease;
        }

        .member-item:hover,
        .article-item:hover {
            background-color: var(--tm-soft-coral);
            transform: translateX(2px);
        }

        .member-item.member-nav-target {
            cursor: pointer;
        }

        /* Styling for the precinct label prefix inside member rows */
        .precinct-label {
            font-weight: 600;
            color: var(--tm-plum);
        }

        /* Centered loading / error text */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--tm-plum);
        }

        .cluster-status {
            margin-bottom: 16px;
            padding: 12px 16px;
            background-color: var(--tm-soft-navy);
            border: 1px solid var(--tm-line);
            border-radius: 8px;
            font-size: 14px;
            color: var(--tm-navy);
        }

        .cluster-status.error {
            background-color: var(--tm-soft-coral);
            border-color: rgba(246, 48, 73, 0.4);
            color: var(--tm-rose);
        }

        .cluster-controls {
            align-items: flex-start;
        }

        .cluster-control-block {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 360px;
        }

        .cluster-control-inline {
            display: flex;
            gap: 14px;
            align-items: center;
            flex-wrap: wrap;
        }

        .cluster-inline-select {
            min-width: 170px;
        }

        .cluster-member-search-group {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
            flex-wrap: nowrap;
        }

        .cluster-member-search-group label {
            white-space: nowrap;
        }

        .cluster-member-search-group .cluster-search-input {
            flex: 1 1 auto;
            min-width: 220px;
        }

        .cluster-search-input {
            min-width: 260px;
            padding: 10px 15px;
            border: 2px solid var(--tm-line);
            border-radius: 8px;
            font-size: 15px;
            background-color: white;
            transition: border-color 0.3s ease;
        }

        .cluster-search-input:hover {
            border-color: var(--tm-coral);
        }

        .cluster-search-input:focus {
            outline: none;
            border-color: var(--tm-coral);
            box-shadow: 0 0 0 3px var(--tm-focus);
        }

        .cluster-action-btn {
            padding: 10px 14px;
            border: 2px solid var(--tm-rose);
            border-radius: 8px;
            background-color: var(--tm-rose);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cluster-action-btn:hover {
            background-color: var(--tm-plum);
            border-color: var(--tm-plum);
        }

        .session-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .session-option {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border: 1px solid var(--tm-line);
            border-radius: 6px;
            background-color: var(--tm-soft-navy);
            font-size: 13px;
            color: var(--tm-navy);
        }

        .session-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .cluster-slider-group {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background-color: var(--tm-soft-navy);
            border: 1px solid var(--tm-line);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .cluster-slider-group input[type="range"] {
            width: 180px;
            accent-color: var(--tm-coral);
        }

        .cluster-slider-value {
            min-width: 36px;
            font-weight: 600;
            color: var(--tm-navy);
            text-align: right;
        }

        .cluster-plot {
            width: 100%;
            height: 600px;
            border: 1px solid var(--tm-line);
            border-radius: 10px;
            background-color: #fff;
        }

        .cluster-panels {
            display: grid;
            grid-template-columns: repeat(2, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .cluster-panel {
            background-color: var(--tm-soft-navy);
            border: 1px solid var(--tm-line);
            border-radius: 10px;
            padding: 16px;
        }

        .cluster-panel.member-detail {
            grid-column: 1 / -1;
        }

        .cluster-panel h3 {
            margin-bottom: 12px;
            color: var(--tm-navy);
            font-size: 17px;
        }

        .cluster-panel-body {
            font-size: 14px;
            color: #444;
        }

        .cluster-message {
            color: #666;
            font-style: italic;
        }

        .cluster-member-meta {
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .cluster-neighbor-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .cluster-neighbor-list li {
            padding: 8px 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background-color: #fff;
            margin-bottom: 6px;
            line-height: 1.4;
        }

        .member-network-table-wrap {
            overflow: auto;
            max-height: 860px;
        }

        .member-network-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 520px;
            table-layout: fixed;
        }

        .member-network-table th,
        .member-network-table td {
            border: 1px solid var(--tm-line);
            padding: 8px 10px;
            text-align: center;
            font-size: 14px;
            line-height: 1.35;
            background-color: #fff;
        }

        .member-network-table th {
            background-color: var(--tm-soft-navy);
            color: var(--tm-navy);
            font-weight: 600;
        }

        .member-network-sort-btn {
            width: 100%;
            border: 0;
            padding: 0;
            margin: 0;
            background: transparent;
            color: inherit;
            font: inherit;
            font-weight: 600;
            text-align: inherit;
            cursor: pointer;
        }

        .member-network-sort-btn:hover {
            color: var(--tm-rose);
        }

        .member-network-table .rank-col {
            width: 56px;
            white-space: nowrap;
        }

        .member-network-table .member-col {
            width: 200px;
            white-space: normal;
            overflow-wrap: anywhere;
        }

        .member-network-table .precinct-col {
            width: 92px;
            white-space: nowrap;
            text-align: center;
        }

        .member-network-table .shared-col {
            width: 112px;
            white-space: nowrap;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .member-network-table .sim-col {
            width: 96px;
            white-space: nowrap;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .axis-component {
            margin-bottom: 16px;
            background-color: #fff;
            border: 1px solid var(--tm-line);
            border-radius: 8px;
            padding: 10px 12px;
        }

        .axis-component h4 {
            margin-bottom: 8px;
            color: var(--tm-navy);
            font-size: 14px;
        }

        .axis-direction {
            margin-bottom: 8px;
            font-size: 13px;
            line-height: 1.4;
        }

        .axis-direction strong {
            color: var(--tm-navy);
        }

        .vote-history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .vote-history-session {
            border: 1px solid var(--tm-line);
            border-radius: 8px;
            background-color: #fbf8fa;
            overflow: hidden;
        }

        .vote-history-session summary {
            cursor: pointer;
            padding: 10px 14px;
            font-weight: 600;
            color: var(--tm-navy);
            background-color: var(--tm-soft-navy);
            list-style: none;
        }

        .vote-history-session summary::-webkit-details-marker {
            display: none;
        }

        .vote-history-session[open] summary {
            border-bottom: 1px solid var(--tm-line);
        }

        .vote-history-table-wrap {
            overflow-x: auto;
            background-color: white;
        }

        .vote-history-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1250px;
        }

        .vote-history-table th,
        .vote-history-table td {
            border: 1px solid var(--tm-line);
            padding: 8px 10px;
            text-align: left;
            vertical-align: top;
            font-size: 13px;
            line-height: 1.35;
        }

        .vote-history-table th {
            background-color: var(--tm-soft-navy);
            color: var(--tm-navy);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .vote-history-table .num-col {
            text-align: right;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }

        .vote-history-table th:nth-child(1),
        .vote-history-table td:nth-child(1) {
            min-width: 96px;
            white-space: nowrap;
        }

        .vote-history-table th:nth-child(2),
        .vote-history-table td:nth-child(2) {
            min-width: 130px;
            white-space: nowrap;
        }

        .vote-history-table th:nth-child(5),
        .vote-history-table td:nth-child(5),
        .vote-history-table th:nth-child(6),
        .vote-history-table td:nth-child(6),
        .vote-history-table th:nth-child(7),
        .vote-history-table td:nth-child(7),
        .vote-history-table th:nth-child(8),
        .vote-history-table td:nth-child(8) {
            width: 88px;
            min-width: 88px;
            max-width: 88px;
            text-align: left;
        }

        .vote-history-table .description-col {
            min-width: 220px;
        }

        .vote-history-table .link-col {
            white-space: nowrap;
            text-align: center;
        }

        .vote-history-table th:nth-child(10),
        .vote-history-table td:nth-child(10),
        .vote-history-table th:nth-child(11),
        .vote-history-table td:nth-child(11),
        .vote-history-table th:nth-child(12),
        .vote-history-table td:nth-child(12),
        .vote-history-table th:nth-child(13),
        .vote-history-table td:nth-child(13) {
            text-align: center;
        }

        .vote-history-message {
            padding: 12px 14px;
            border: 1px solid #e0e7ee;
            border-radius: 8px;
            background-color: #f8f9fa;
            color: #4a5b6b;
            font-size: 14px;
        }

        .contentious-votes-controls {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 14px;
            flex-wrap: wrap;
        }

        .contentious-votes-table-wrap {
            overflow: auto;
            max-height: 860px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background-color: #fff;
        }

        .contentious-votes-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 960px;
            table-layout: fixed;
        }

        .contentious-votes-table th,
        .contentious-votes-table td {
            border: 1px solid #e9ecef;
            padding: 8px 10px;
            text-align: left;
            vertical-align: top;
            font-size: 13px;
            line-height: 1.35;
        }

        .contentious-votes-table th {
            background-color: #f1f5f8;
            color: #2c3e50;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .contentious-votes-table .description-col {
            min-width: 260px;
        }

        .contentious-votes-table .num-col {
            width: 84px;
            min-width: 84px;
            white-space: nowrap;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .contentious-votes-table th:nth-child(7),
        .contentious-votes-table td:nth-child(7) {
            width: 72px;
            min-width: 72px;
        }

        .contentious-votes-table th:nth-child(7) {
            white-space: normal;
            line-height: 1.2;
        }

        .contentious-votes-table th:nth-child(8),
        .contentious-votes-table td:nth-child(8) {
            width: 96px;
            min-width: 96px;
        }

        .precinct-votes-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .precinct-votes-table-wrap {
            overflow: auto;
            max-height: min(68vh, 640px);
            background-color: white;
            overscroll-behavior: contain;
        }

        .precinct-votes-scroll-top {
            display: none;
            overflow-x: auto;
            overflow-y: hidden;
            height: 12px;
            background-color: white;
            border-top: 1px solid #e9ecef;
            border-left: 1px solid #e9ecef;
            border-right: 1px solid #e9ecef;
        }

        .precinct-votes-scroll-inner {
            height: 1px;
        }

        .precinct-votes-table {
            /* Keep frozen-column widths and sticky offsets in sync via variables. */
            --precinct-col-1-width: 100px;
            --precinct-col-2-width: 200px;
            --precinct-col-3-width: 100px;
            /* Width for "All" + precinct percentage columns (P1..P17). */
            --precinct-col-width: 50px;
            width: max-content;
            border-collapse: collapse;
            table-layout: fixed;
        }

        .precinct-votes-table th,
        .precinct-votes-table td {
            border: 1px solid var(--tm-line);
            padding: 8px 10px;
            text-align: left;
            vertical-align: top;
            font-size: 13px;
            line-height: 1.35;
            box-sizing: border-box;
        }

        .precinct-votes-table th {
            background-color: var(--tm-soft-navy);
            color: var(--tm-navy);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
            white-space: nowrap;
        }

        .precinct-votes-table th:nth-child(n+4) {
            text-align: right;
        }

        .precinct-votes-table th:nth-child(n+4),
        .precinct-votes-table td:nth-child(n+4) {
            width: var(--precinct-col-width);
            min-width: var(--precinct-col-width);
            max-width: var(--precinct-col-width);
            padding-left: 4px;
            padding-right: 4px;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }

        .precinct-votes-table th:nth-child(1),
        .precinct-votes-table td:nth-child(1) {
            width: var(--precinct-col-1-width);
            min-width: var(--precinct-col-1-width);
            max-width: var(--precinct-col-1-width);
            position: sticky;
            left: 0;
            z-index: 3;
            background-color: white;
        }

        .precinct-votes-table th:nth-child(2),
        .precinct-votes-table td:nth-child(2) {
            width: var(--precinct-col-2-width);
            min-width: var(--precinct-col-2-width);
            max-width: var(--precinct-col-2-width);
            position: sticky;
            /* Sticky start exactly after column 1. */
            left: var(--precinct-col-1-width);
            z-index: 3;
            background-color: white;
        }

        .precinct-votes-table th:nth-child(3),
        .precinct-votes-table td:nth-child(3) {
            width: var(--precinct-col-3-width);
            min-width: var(--precinct-col-3-width);
            max-width: var(--precinct-col-3-width);
            white-space: nowrap;
            position: sticky;
            /* Sticky start exactly after columns 1 and 2. */
            left: calc(var(--precinct-col-1-width) + var(--precinct-col-2-width));
            z-index: 3;
            background-color: white;
        }

        .precinct-votes-table th:nth-child(1),
        .precinct-votes-table th:nth-child(2),
        .precinct-votes-table th:nth-child(3) {
            z-index: 6;
            background-color: #f1f5f8;
        }

        .precinct-votes-table .description-col {
            width: var(--precinct-col-2-width);
            min-width: var(--precinct-col-2-width);
            max-width: var(--precinct-col-2-width);
        }

        .precinct-votes-table .aggregate-col {
            text-align: center;
        }

        .precinct-votes-table .pct-col {
            text-align: center;
        }

        .page-footer {
            margin-top: 28px;
            padding-top: 18px;
            border-top: 1px solid #e3e8ed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .page-footer-text {
            text-align: center;
            color: #445566;
            font-size: 16px;
            line-height: 1.45;
        }

        .page-footer-text a {
            color: inherit;
            text-decoration: underline;
        }

        .page-footer-credit {
            font-weight: 700;
        }

        .page-footer-logo {
            width: 120px;
            height: auto;
            display: block;
            flex: 0 0 auto;
        }

        @media (max-width: 900px) {
            select {
                min-width: 220px;
            }

            .cluster-control-block {
                min-width: 280px;
            }

            .cluster-panels {
                grid-template-columns: 1fr;
            }

            .page-footer-logo {
                width: 80px;
            }

            .results {
                grid-template-columns: repeat(2, minmax(260px, 1fr));
            }
        }

        @media (max-width: 640px) {
            select {
                min-width: 180px;
            }

            .cluster-member-search-group {
                width: 100%;
            }

            .cluster-member-search-group .cluster-search-input {
                min-width: 0;
            }

            .results {
                grid-template-columns: 1fr;
            }

            .cluster-plot {
                height: 480px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Brookline Town Meeting Voting Analysis</h1>
        <p class="subtitle">Research voting patterns at Brookline's Town Meeting</p>

        <!-- Shown initially while spreadsheet data is being fetched and parsed -->
        <div class="loading" id="loading">
            Loading voting data...
        </div>

        <!-- All main content is hidden until data is successfully loaded -->
        <div id="main-content" style="display: none;">

            <!-- Module selector buttons -->
            <div class="tabs" id="module-menu">
                <button class="tab active" data-tab="by-vote" onclick="switchTab(event, 'by-vote')">View by Vote</button>
                <button class="tab" data-tab="by-member" onclick="switchTab(event, 'by-member')">View by Member</button>
                <button class="tab" data-tab="member-networks" onclick="switchTab(event, 'member-networks')">Member Networks</button>
                <button class="tab" data-tab="vote-history" onclick="switchTab(event, 'vote-history')">Vote History</button>
                <button class="tab" data-tab="precinct-votes" onclick="switchTab(event, 'precinct-votes')">Precinct Votes</button>
                <button class="tab" data-tab="contentious-votes" onclick="switchTab(event, 'contentious-votes')">Closest Votes</button>
            </div>
            <div id="module-instruction" class="module-instruction"></div>

            <!-- Context controls shown for modules that operate on a single session -->
            <div id="module-context-controls" class="controls" style="margin-bottom: 20px;">
                <div id="single-session-controls" class="control-group">
                    <label for="spreadsheet-select">Select Town Meeting:</label>
                    <!--
                        value is URL-encoded file name located in:
                        https://github.com/millxing/TM/blob/main/<file>
                        which is fetched via the GitHub raw URL.
                    -->
                    <select id="spreadsheet-select">
                        <option value="Votes/November%202025%20Votes.xlsx" selected>November 2025 Special Town Meeting (19 votes)</option>
                        <option value="Votes/May%202025%20Votes.xlsx">May 2025 Annual Town Meeting (45 votes)</option>
                        <option value="Votes/November%202024%20Votes.xlsx">November 2024 Special Town Meeting (28 votes)</option>
                        <option value="Votes/May%202024%20Votes.xlsx">May 2024 Annual Town Meeting (34 votes)</option>
                        <option value="Votes/November%202023%20Votes.xlsx">November 2023 Special Town Meeting (24 votes)</option>
                        <option value="Votes/May%202023%20Votes.xlsx">May 2023 Annual Town Meeting (44 votes)</option>
                        <option value="Votes/January%202023%20Votes.xlsx">January 2023 Special Town Meeting (4 votes)</option>
                        <option value="Votes/November%202022%20Votes.xlsx">November 2022 Special Town Meeting (68 votes)</option>
                        <option value="Votes/May%202022%20Votes.xlsx">May 2022 Annual Town Meeting (57 votes)</option>
                        <option value="Votes/November%202021%20Votes.xlsx">November 2021 Special Town Meeting (48 votes)</option>
                        <option value="Votes/October%202021%20Votes.xlsx">October 2021 Special Town Meeting (10 votes)</option>
                        <option value="Votes/May%202021%20Votes.xlsx">May 2021 Annual Town Meeting (68 votes)</option>
                    </select>
                </div>
            </div>

            <!-- TAB: View by Vote -->
            <div id="by-vote" class="tab-content active">
                <div class="controls">
                    <div class="control-group">
                        <label for="vote-select">Select Vote:</label>
                        <!-- Populated dynamically with article titles from the spreadsheet -->
                        <select id="vote-select"></select>
                        <div class="checkbox-group">
                            <!-- When checked, sorts by last name only instead of precinct+name -->
                            <input type="checkbox" id="sort-by-name-vote" onchange="updateVoteResults()">
                            <label for="sort-by-name-vote">Sort by last name only</label>
                        </div>
                    </div>
                </div>
                <!-- Container where the four vote-columns (Yes/No/Abstain/No Vote) are rendered -->
                <div id="vote-results" class="vote-results-container"></div>
            </div>

            <!-- TAB: View by Member -->
            <div id="by-member" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label for="member-select">Select Member:</label>
                        <!-- Populated dynamically with "Name (Precinct X)" options -->
                        <select id="member-select"></select>
                        <div class="checkbox-group">
                            <!-- When checked, sort member dropdown by precinct then name -->
                            <input type="checkbox" id="sort-by-precinct-member" onchange="populateMemberDropdown()">
                            <label for="sort-by-precinct-member">Sort by precinct, then name</label>
                        </div>
                    </div>
                </div>
                <!-- Grid of four columns: for this one member, show which articles they voted Yes/No/Abstain/No Vote -->
                <div id="member-results" class="results"></div>
            </div>

            <!-- TAB: Member Networks -->
            <div id="member-networks" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label for="member-network-select">Select Member:</label>
                        <select id="member-network-select" onchange="updateMemberNetworkResults()"></select>
                        <div class="checkbox-group">
                            <input
                                type="checkbox"
                                id="sort-by-precinct-network"
                                checked
                                onchange="populateMemberNetworkDropdown(); updateMemberNetworkResults()">
                            <label for="sort-by-precinct-network">Sort by precinct, then last name</label>
                        </div>
                        <div class="checkbox-group">
                            <input
                                type="checkbox"
                                id="member-network-ignore-terminate"
                                checked
                                onchange="updateMemberNetworkResults()">
                            <label for="member-network-ignore-terminate">Ignore motions to terminate debate</label>
                        </div>
                        <div class="checkbox-group">
                            <input
                                type="checkbox"
                                id="member-network-ignore-abstain"
                                checked
                                onchange="updateMemberNetworkResults()">
                            <label for="member-network-ignore-abstain">Ignore abstain votes</label>
                        </div>
                    </div>
                </div>

                <div id="member-network-status" class="cluster-status">
                    Select a member to view nearest voting neighbors.
                </div>

                <div class="cluster-panels">
                    <div class="cluster-panel member-detail">
                        <h3>Closest Members</h3>
                        <div id="member-network-neighbors" class="cluster-panel-body">
                            <div class="cluster-message">Select a member to compute voting similarity.</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB: Vote History -->
            <div id="vote-history" class="tab-content">
                <div id="vote-history-results" class="vote-history-message">Open this module to load all sessions.</div>
            </div>

            <!-- TAB: Precinct Votes -->
            <div id="precinct-votes" class="tab-content">
                <div id="precinct-votes-results" class="vote-history-message">Open this module to load all sessions.</div>
            </div>

            <!-- TAB: Contentious Votes -->
            <div id="contentious-votes" class="tab-content">
                <div class="controls contentious-votes-controls">
                    <div class="checkbox-group">
                        <input
                            type="checkbox"
                            id="contentious-ignore-terminate"
                            checked
                            onchange="renderContentiousVotes()">
                        <label for="contentious-ignore-terminate">Ignore motions to terminate debate</label>
                    </div>
                </div>
                <div id="contentious-votes-results" class="vote-history-message">Open this module to load all sessions.</div>
            </div>

            <!-- TAB: Voter Clustering -->
            <div id="voter-clustering" class="tab-content">
                <div class="controls">
                    <div class="control-group cluster-controls">
                        <div class="cluster-control-block">
                            <label>Sessions to include:</label>
                            <div id="cluster-session-checkboxes" class="session-checkboxes"></div>
                        </div>
                        <div class="cluster-control-inline">
                            <label for="cluster-min-sessions">Minimum sessions:</label>
                            <select id="cluster-min-sessions" class="cluster-inline-select"></select>

                            <div class="cluster-slider-group">
                                <label for="cluster-terminate-weight">Terminate Debate weight:</label>
                                <input type="range" id="cluster-terminate-weight" min="0" max="1" step="0.1" value="0">
                                <span id="cluster-terminate-weight-value" class="cluster-slider-value">0.0</span>
                            </div>

                            <label for="cluster-color-by">Color by:</label>
                            <select id="cluster-color-by" class="cluster-inline-select">
                                <option value="precinct">Precinct</option>
                                <option value="sessions">Number of sessions attended</option>
                                <option value="none" selected>None</option>
                            </select>

                            <div class="cluster-member-search-group">
                                <label for="cluster-member-search">Find member:</label>
                                <input
                                    type="search"
                                    id="cluster-member-search"
                                    class="cluster-search-input"
                                    list="cluster-member-options"
                                    placeholder="Type member name..."
                                    autocomplete="off">
                                <button type="button" id="cluster-member-search-go" class="cluster-action-btn">Select</button>
                            </div>
                            <datalist id="cluster-member-options"></datalist>
                        </div>
                    </div>
                </div>

                <div id="cluster-status" class="cluster-status">Open this tab to load all sessions.</div>
                <div id="cluster-plot" class="cluster-plot"></div>

                <div class="cluster-panels">
                    <div class="cluster-panel member-detail">
                        <h3>Selected Member</h3>
                        <div id="cluster-member-detail" class="cluster-panel-body">
                            <div class="cluster-message">Click a dot to view this member's aggregated voting summary.</div>
                        </div>
                    </div>
                    <div class="cluster-panel">
                        <h3>Nearest Neighbors</h3>
                        <div id="cluster-neighbors" class="cluster-panel-body">
                            <div class="cluster-message">Click a dot to view the 10 most similar members.</div>
                        </div>
                    </div>
                    <div class="cluster-panel">
                        <h3>Axis Interpretation</h3>
                        <div id="cluster-axis-info" class="cluster-panel-body">
                            <div class="cluster-message">Run clustering to inspect top positive and negative loadings for PC1 and PC2.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="page-footer">
            <div class="page-footer-text">
                <p>If you find any bugs or errors, please report them to: robschoen.robschoen at gmail dot com</p>
                <p class="page-footer-credit">created by Rob Schoen TMM P1 // Entangled Particles // <a href="https://www.longwoodmall.org" target="_blank" rel="noopener noreferrer">www.longwoodmall.org</a></p>
            </div>
            <img class="page-footer-logo" src="entangledParticlesLogo.jpg" alt="Entangled Particles logo">
        </footer>
    </div>


    <script>
        /****************************************************
         * SPREADSHEET STRUCTURE CONFIGURATION
         ****************************************************/

        const TITLE_ROW_INDEX = 2;
        const DESCRIPTION_ROW_INDEX = 3;
        const HEADER_ROW_INDEX = 4;
        const FIRST_DATA_ROW_INDEX = 5;

        const PRECINCT_COL_INDEX = 0;
        const NAME_COL_INDEX = 1;
        const FIRST_VOTE_COL_INDEX = 2;
        const VOTE_GUIDE_FILE_NAMES = [
            'VoteGuide.xlsx',
            'Vote%20Guide.xlsx',
            'voteguide.xlsx'
        ];
        const MEMBER_ALIASES_FILE_NAMES = [
            'members_aliases.xlsx',
            'members%20aliases.xlsx',
            'member_aliases.xlsx',
            'MemberAliases.xlsx'
        ];

        const SPREADSHEET_BASE_URL = 'https://raw.githubusercontent.com/millxing/TM/main/';
        const DISALLOWED_MEMBER_NAMES = new Set(['YES', 'NO', 'ABSTAIN', 'NO VOTE', 'TOTAL', 'ARTICLE', 'MOTION']);
        // Fallback alias overrides for known name variants.
        const DEFAULT_MEMBER_IDENTITY_ALIASES = new Map([
            ['ingraham, katherine a', 'ingraham, katherine'],
            ['warren, paul s', 'warren, paul']
        ]);
        const SESSION_FILES = [
            { id: '2021-05', label: 'May 2021 Annual Town Meeting', file: 'Votes/May%202021%20Votes.xlsx' },
            { id: '2021-10', label: 'October 2021 Special Town Meeting', file: 'Votes/October%202021%20Votes.xlsx' },
            { id: '2021-11', label: 'November 2021 Special Town Meeting', file: 'Votes/November%202021%20Votes.xlsx' },
            { id: '2022-05', label: 'May 2022 Annual Town Meeting', file: 'Votes/May%202022%20Votes.xlsx' },
            { id: '2022-11', label: 'November 2022 Special Town Meeting', file: 'Votes/November%202022%20Votes.xlsx' },
            { id: '2023-01', label: 'January 2023 Special Town Meeting', file: 'Votes/January%202023%20Votes.xlsx' },
            { id: '2023-05', label: 'May 2023 Annual Town Meeting', file: 'Votes/May%202023%20Votes.xlsx' },
            { id: '2023-11', label: 'November 2023 Special Town Meeting', file: 'Votes/November%202023%20Votes.xlsx' },
            { id: '2024-05', label: 'May 2024 Annual Town Meeting', file: 'Votes/May%202024%20Votes.xlsx' },
            { id: '2024-11', label: 'November 2024 Special Town Meeting', file: 'Votes/November%202024%20Votes.xlsx' },
            { id: '2025-05', label: 'May 2025 Annual Town Meeting', file: 'Votes/May%202025%20Votes.xlsx' },
            { id: '2025-11', label: 'November 2025 Special Town Meeting', file: 'Votes/November%202025%20Votes.xlsx' }
        ];
        const SESSION_ORDER_INDEX = SESSION_FILES.reduce((acc, session, index) => {
            acc[session.id] = index;
            return acc;
        }, {});
        const COUNTED_VOTE_OVERRIDES = {
            '2025-11::article 19 main motion to table': {
                counts: { YES: 146, NO: 78, ABSTAIN: 7, NoVote: 32 },
                detailLine: 'FAILED 146-78-7, required 2/3 majority'
            },
            '2025-11::article 19 main motion': {
                counts: { YES: 141, NO: 27, ABSTAIN: 20, NoVote: 75 },
                detailLine: 'APPROVED 141-27-20'
            }
        };
        // Canonical precinct list used by cross-session precinct reporting.
        const STANDARD_PRECINCTS = Array.from({ length: 17 }, (_, idx) => String(idx + 1));

        /****************************************************
         * GLOBAL STATE
         ****************************************************/

        let LAST_VOTE_COL_INDEX = 100;
        let votingData = null;
        let votes = [];
        let members = [];
        let memberAliasesLoadPromise = null;
        let memberAliasesLoadComplete = false;
        let memberIdentityAliases = new Map(DEFAULT_MEMBER_IDENTITY_ALIASES);
        let memberIdentityCanonicalDisplayNames = new Map();
        let voteGuideLoadPromise = null;
        let voteGuideLoadComplete = false;
        let voteGuideBySessionAndVote = new Map();
        let voteGuideBySessionAndLooseVote = new Map();
        let voteHistorySessionsCache = null;
        let voteHistoryLoadPromise = null;
        let precinctVotesLoadPromise = null;
        let contentiousVotesLoadPromise = null;
        let memberNetworkProfilesCache = null;
        let memberNetworkProfileByKey = new Map();
        let memberNetworkLoadPromise = null;
        let memberNetworkCurrentData = null;
        let memberNetworkSortState = { key: 'baseRank', direction: 'asc' };

        let clusteringSessionsCache = null;
        let clusteringLoadPromise = null;
        let clusteringControlsInitialized = false;
        let clusteringDebounceTimer = null;
        let clusteringAnalysisState = null;
        let selectedClusterMemberKey = null;
        const clusterMemberSearchLabelToKey = new Map();
        const clusterMemberSearchKeyToLabel = new Map();
        const APP_MODE = new URLSearchParams(window.location.search).get('app') === 'vote-analyzer'
            ? 'vote-analyzer'
            : 'tmmvotes';
        const SINGLE_SESSION_MODULE_IDS = new Set(['by-vote', 'by-member']);

        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        const moduleInstructionEl = document.getElementById('module-instruction');
        const moduleContextControlsEl = document.getElementById('module-context-controls');
        const memberNetworkStatusEl = document.getElementById('member-network-status');
        const memberNetworkNeighborsEl = document.getElementById('member-network-neighbors');
        const clusterStatusEl = document.getElementById('cluster-status');
        const clusterPlotEl = document.getElementById('cluster-plot');
        const clusterMemberDetailEl = document.getElementById('cluster-member-detail');
        const clusterNeighborsEl = document.getElementById('cluster-neighbors');
        const clusterAxisInfoEl = document.getElementById('cluster-axis-info');

        /****************************************************
         * URL / FILE HELPERS
         ****************************************************/

        function getSpreadsheetRawURL(file) {
            return `${SPREADSHEET_BASE_URL}${file}`;
        }

        function getSelectedSpreadsheetURL() {
            const select = document.getElementById('spreadsheet-select');
            const file = select ? select.value : 'Votes/November%202025%20Votes.xlsx';
            return getSpreadsheetRawURL(file);
        }

        function getCurrentSpreadsheetMeta() {
            const select = document.getElementById('spreadsheet-select');
            const selectedIndex = select ? select.selectedIndex : -1;
            const option = select && selectedIndex >= 0 ? select.options[selectedIndex] : null;
            const file = option ? option.value : 'Votes/November%202025%20Votes.xlsx';
            const labelText = option ? option.textContent : 'Selected Session';
            const label = labelText ? labelText.split('(')[0].trim() : 'Selected Session';
            const knownSession = SESSION_FILES.find(session => session.file === file);

            return {
                id: knownSession ? knownSession.id : 'single-session',
                label: knownSession ? knownSession.label : label,
                file
            };
        }

        function buildVoteGuideCandidateFiles() {
            const selectedMeta = getCurrentSpreadsheetMeta();
            const selectedFile = String(selectedMeta.file || '');
            const selectedDir = selectedFile.includes('/')
                ? selectedFile.slice(0, selectedFile.lastIndexOf('/') + 1)
                : '';

            const candidateSet = new Set();

            // Try sibling directory first, then legacy fallbacks used in earlier commits.
            VOTE_GUIDE_FILE_NAMES.forEach(name => {
                if (selectedDir) candidateSet.add(`${selectedDir}${name}`);
                candidateSet.add(`Votes/${name}`);
                candidateSet.add(`Vote/${name}`);
                candidateSet.add(name);
            });

            return Array.from(candidateSet);
        }

        function buildMemberAliasesCandidateFiles() {
            const selectedMeta = getCurrentSpreadsheetMeta();
            const selectedFile = String(selectedMeta.file || '');
            const selectedDir = selectedFile.includes('/')
                ? selectedFile.slice(0, selectedFile.lastIndexOf('/') + 1)
                : '';

            const candidateSet = new Set();
            MEMBER_ALIASES_FILE_NAMES.forEach(name => {
                if (selectedDir) candidateSet.add(`${selectedDir}${name}`);
                candidateSet.add(`Votes/${name}`);
                candidateSet.add(`Vote/${name}`);
                candidateSet.add(name);
            });

            return Array.from(candidateSet);
        }

        /****************************************************
         * DATA NORMALIZATION & SORT HELPERS
         ****************************************************/

        function precinctSortValue(precinct) {
            const n = parseInt(precinct, 10);
            if (!isNaN(n)) return n;
            if (String(precinct).toUpperCase() === 'AL') return 999;
            return 998;
        }

        function normalizeVote(raw) {
            // Keep this contract strict; downstream views assume only these 4 buckets.
            const value = (raw == null ? '' : String(raw)).trim().toUpperCase();
            if (!value) return 'NoVote';
            if (value === 'Y') return 'YES';
            if (value === 'N') return 'NO';
            if (value === 'A') return 'ABSTAIN';
            if (value === 'YES' || value === 'NO' || value === 'ABSTAIN') return value;
            return 'NoVote';
        }

        function voteToNumeric(voteValue) {
            if (voteValue === 'YES') return 1;
            if (voteValue === 'NO') return -1;
            if (voteValue === 'ABSTAIN') return 0;
            return NaN;
        }

        function normalizeMemberName(name) {
            return String(name || '').trim().toLowerCase().replace(/\s+/g, ' ');
        }

        function normalizeMemberAliasToken(name) {
            return normalizeMemberName(name)
                .replace(/\./g, '')
                .replace(/\s*,\s*/g, ', ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function reorderNameIfLikelyFirstLast(normalizedName) {
            if (!normalizedName || normalizedName.includes(',')) return '';
            const tokens = normalizedName.split(/\s+/).filter(Boolean);
            if (tokens.length < 2) return '';

            const suffixPattern = /^(jr|sr|ii|iii|iv|v|vi)$/i;
            let suffix = '';
            if (tokens.length > 2 && suffixPattern.test(tokens[tokens.length - 1])) {
                suffix = tokens.pop();
            }

            const last = tokens.pop();
            if (!last || tokens.length === 0) return '';
            const given = suffix ? [...tokens, suffix] : tokens;
            return `${last}, ${given.join(' ')}`.replace(/\s+/g, ' ').trim();
        }

        function stripLikelyMiddleInitials(normalizedName) {
            if (!normalizedName) return '';

            if (normalizedName.includes(',')) {
                const parts = normalizedName.split(',');
                const last = (parts[0] || '').trim();
                const given = (parts.slice(1).join(',') || '').trim();
                if (!given) return last;

                const tokens = given
                    .replace(/\./g, '')
                    .split(/\s+/)
                    .filter(Boolean);

                if (tokens.length > 1 && /^[a-z]$/.test(tokens[tokens.length - 1])) {
                    tokens.pop();
                }

                return `${last}, ${tokens.join(' ')}`.replace(/\s+/g, ' ').trim();
            }

            const tokens = normalizedName
                .replace(/\./g, '')
                .split(/\s+/)
                .filter(Boolean);

            if (tokens.length > 1 && /^[a-z]$/.test(tokens[tokens.length - 1])) {
                tokens.pop();
            } else if (tokens.length === 3 && /^[a-z]$/.test(tokens[1])) {
                tokens.splice(1, 1);
            }

            return tokens.join(' ');
        }

        function canonicalMemberIdentityName(name) {
            const normalized = normalizeMemberAliasToken(name);
            if (!normalized) return '';

            const candidates = [];
            const pushCandidate = value => {
                const token = normalizeMemberAliasToken(value);
                if (token && !candidates.includes(token)) candidates.push(token);
            };

            pushCandidate(normalized);
            pushCandidate(stripLikelyMiddleInitials(normalized));

            const reordered = reorderNameIfLikelyFirstLast(normalized);
            if (reordered) {
                pushCandidate(reordered);
                pushCandidate(stripLikelyMiddleInitials(reordered));
            }

            for (const candidate of candidates) {
                const mapped = memberIdentityAliases.get(candidate);
                if (mapped) return mapped;
            }

            return candidates[1] || candidates[0];
        }

        function preferDisplayName(existingName, incomingName) {
            const existing = String(existingName || '').trim();
            const incoming = String(incomingName || '').trim();
            if (!existing) return incoming;
            if (!incoming) return existing;
            if (incoming.length < existing.length) return incoming;
            return existing;
        }

        function summarizePrecinctSet(precinctSet) {
            const items = Array.from(precinctSet || []).filter(Boolean);
            if (items.length === 0) return '';
            if (items.length === 1) return items[0];
            if (items.includes('AL')) return 'AL';
            const numeric = items
                .map(value => parseInt(value, 10))
                .filter(value => !isNaN(value))
                .sort((a, b) => a - b);
            if (numeric.length > 0) return String(numeric[0]);
            return items[0];
        }

        function getSessionOrderIndex(sessionId) {
            return SESSION_ORDER_INDEX[sessionId] !== undefined ? SESSION_ORDER_INDEX[sessionId] : -1;
        }

        function canonicalMemberKey(name, precinct) {
            // Cross-session identity intentionally ignores precinct so redistricting/AL service doesn't split members.
            void precinct;
            return canonicalMemberIdentityName(name);
        }

        function formatPrecinctLabel(precinct) {
            const up = String(precinct).toUpperCase();
            if (up === 'AL') return 'AL';
            if (up === 'MULTI') return 'MULTI';
            return `P${precinct}`;
        }

        function getLastNameForSort(name) {
            const normalized = String(name || '').trim();
            if (!normalized) return '';

            // Prefer "Last, First" format when present.
            if (normalized.includes(',')) {
                return normalized.split(',')[0].trim().toLowerCase();
            }

            // Fallback for "First Last" format.
            const parts = normalized.split(/\s+/).filter(Boolean);
            if (parts.length === 0) return '';
            return parts[parts.length - 1].toLowerCase();
        }

        function isTerminateDebateVote(title) {
            return String(title || '').toLowerCase().includes('terminate debate');
        }

        function normalizeVoteResult(value) {
            const text = String(value || '').trim().toUpperCase();
            if (!text) return '';
            if (text.includes('APPROVED')) return 'APPROVED';
            if (text.includes('FAILED')) return 'FAILED';
            return '';
        }

        function extractVoteResultsByColumn(rows, startRowIndex, lastVoteColIndex) {
            if (!Array.isArray(rows) || rows.length === 0) return {};

            let bestRowIndex = -1;
            let bestMatchCount = 0;
            const scanStart = Math.max(0, startRowIndex);

            // Vote-result rows are not always fixed; pick the row with most APPROVED/FAILED matches.
            for (let r = scanStart; r < rows.length; r++) {
                const row = rows[r] || [];
                let matchCount = 0;
                for (let col = FIRST_VOTE_COL_INDEX; col <= lastVoteColIndex; col++) {
                    if (normalizeVoteResult(row[col])) matchCount += 1;
                }

                if (matchCount > bestMatchCount) {
                    bestMatchCount = matchCount;
                    bestRowIndex = r;
                }
            }

            if (bestRowIndex < 0 || bestMatchCount === 0) return {};

            const resultsByCol = {};
            const resultRow = rows[bestRowIndex] || [];
            for (let col = FIRST_VOTE_COL_INDEX; col <= lastVoteColIndex; col++) {
                const voteResult = normalizeVoteResult(resultRow[col]);
                if (voteResult) resultsByCol[col] = voteResult;
            }
            return resultsByCol;
        }

        function normalizeVoteTitleForMatch(title) {
            return String(title || '')
                .toLowerCase()
                .replace(/\s+/g, ' ')
                .trim();
        }

        function buildVoteGuideKey(sessionId, voteTitle) {
            return `${sessionId}||${normalizeVoteTitleForMatch(voteTitle)}`;
        }

        function normalizeVoteTitleForLooseMatch(title) {
            return normalizeVoteTitleForMatch(title)
                .replace(/\barticles\b/g, 'article')
                .replace(/\bmain motion\b/g, 'motion')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function buildLooseVoteGuideKey(sessionId, voteTitle) {
            return `${sessionId}||${normalizeVoteTitleForLooseMatch(voteTitle)}`;
        }

        function getSessionIdFromGuideLabel(sessionLabel) {
            const normalized = String(sessionLabel || '').toLowerCase().trim();
            if (!normalized) return null;

            // Prefer exact known labels from SESSION_FILES before parsing month/year text.
            const direct = SESSION_FILES.find(session =>
                normalized.includes(session.label.toLowerCase())
            );
            if (direct) return direct.id;

            const match = normalized.match(/\b(january|may|october|november)\s+(20\d{2})\b/i);
            if (!match) return null;

            const monthMap = { january: '01', may: '05', october: '10', november: '11' };
            const month = monthMap[match[1].toLowerCase()];
            const year = match[2];
            const candidate = `${year}-${month}`;
            return SESSION_ORDER_INDEX[candidate] !== undefined ? candidate : null;
        }

        function getVoteGuideDetails(sessionId, voteTitle) {
            if (!sessionId || voteGuideBySessionAndVote.size === 0) return null;
            return (
                voteGuideBySessionAndVote.get(buildVoteGuideKey(sessionId, voteTitle)) ||
                voteGuideBySessionAndLooseVote.get(buildLooseVoteGuideKey(sessionId, voteTitle)) ||
                null
            );
        }

        function buildArticleLinksElement(links) {
            if (!Array.isArray(links) || links.length === 0) return null;

            const sanitizedLinks = links
                .map(link => String(link || '').trim())
                .filter(link => /^https?:\/\//i.test(link));
            if (sanitizedLinks.length === 0) return null;

            const listEl = document.createElement('ul');
            listEl.className = 'article-links';

            sanitizedLinks.forEach((url, index) => {
                const itemEl = document.createElement('li');
                const linkEl = document.createElement('a');
                linkEl.href = url;
                linkEl.target = '_blank';
                linkEl.rel = 'noopener noreferrer';
                linkEl.textContent = `Reference ${index + 1}`;
                itemEl.appendChild(linkEl);
                listEl.appendChild(itemEl);
            });

            return listEl;
        }

        function splitNightDateLabel(nightAndDateText) {
            const raw = String(nightAndDateText || '').trim();
            if (!raw) return { night: '', date: '' };

            let match = raw.match(/^(Night\s*\d+)\s*\(([^)]+)\)$/i);
            if (match) {
                return {
                    night: match[1].trim(),
                    date: match[2].trim()
                };
            }

            match = raw.match(/^(Night\s*\d+)\s*[-–:]\s*(.+)$/i);
            if (match) {
                return {
                    night: match[1].trim(),
                    date: match[2].trim()
                };
            }

            match = raw.match(/^(.+?)\s*\(([^)]+)\)$/);
            if (match) {
                return {
                    night: match[1].trim(),
                    date: match[2].trim()
                };
            }

            return { night: raw, date: '' };
        }

        function normalizeVoteTitleKey(title) {
            return String(title || '')
                .trim()
                .toLowerCase()
                .replace(/\s+/g, ' ');
        }

        function getCountedVoteOverride(sessionId, voteTitle) {
            const key = `${String(sessionId || '').trim()}::${normalizeVoteTitleKey(voteTitle)}`;
            return COUNTED_VOTE_OVERRIDES[key] || null;
        }

        function computeVoteBreakdownFromSession(sessionData, voteMeta) {
            const counts = { YES: 0, NO: 0, ABSTAIN: 0, NoVote: 0 };
            if (!sessionData || !voteMeta || !sessionData.canonicalMembers) return counts;

            const countedOverride = getCountedVoteOverride(sessionData.id, voteMeta.title);
            if (countedOverride && countedOverride.counts) {
                return {
                    YES: Number(countedOverride.counts.YES) || 0,
                    NO: Number(countedOverride.counts.NO) || 0,
                    ABSTAIN: Number(countedOverride.counts.ABSTAIN) || 0,
                    NoVote: Number(countedOverride.counts.NoVote) || 0
                };
            }

            Object.values(sessionData.canonicalMembers).forEach(member => {
                const rawVote = member && member.votesById ? member.votesById[voteMeta.id] : '';
                const normalized = normalizeVote(rawVote);
                if (normalized === 'YES') {
                    counts.YES += 1;
                } else if (normalized === 'NO') {
                    counts.NO += 1;
                } else if (normalized === 'ABSTAIN') {
                    counts.ABSTAIN += 1;
                } else {
                    counts.NoVote += 1;
                }
            });

            return counts;
        }

        function formatYesPercent(yesCount, noCount) {
            const yes = Number(yesCount) || 0;
            const no = Number(noCount) || 0;
            const total = yes + no;
            if (total === 0) return '—';
            return `${Math.round((yes / total) * 100)}%`;
        }

        function normalizeToStandardPrecinct(precinctValue) {
            const raw = String(precinctValue || '').trim();
            const parsed = parseInt(raw, 10);
            if (isNaN(parsed)) return '';
            if (parsed < 1 || parsed > 17) return '';
            return String(parsed);
        }

        function computePrecinctYesPercentages(sessionData, voteMeta) {
            const countsByPrecinct = {};
            STANDARD_PRECINCTS.forEach(precinct => {
                countsByPrecinct[precinct] = { yes: 0, no: 0 };
            });

            if (!sessionData || !voteMeta || !sessionData.canonicalMembers) {
                const empty = {};
                STANDARD_PRECINCTS.forEach(precinct => {
                    empty[precinct] = '—';
                });
                return empty;
            }

            Object.values(sessionData.canonicalMembers).forEach(member => {
                const precinct = normalizeToStandardPrecinct(member ? member.precinct : '');
                if (!precinct) return;

                const rawVote = member && member.votesById ? member.votesById[voteMeta.id] : '';
                const normalized = normalizeVote(rawVote);
                if (normalized === 'YES') {
                    countsByPrecinct[precinct].yes += 1;
                } else if (normalized === 'NO') {
                    countsByPrecinct[precinct].no += 1;
                }
            });

            const percentages = {};
            STANDARD_PRECINCTS.forEach(precinct => {
                const counts = countsByPrecinct[precinct];
                percentages[precinct] = formatYesPercent(counts.yes, counts.no);
            });
            return percentages;
        }

        function getAggregateYesPercentForVote(sessionData, voteMeta, counts) {
            const countedOverride = getCountedVoteOverride(
                sessionData ? sessionData.id : '',
                voteMeta ? voteMeta.title : ''
            );
            if (countedOverride && countedOverride.counts) {
                return formatYesPercent(countedOverride.counts.YES, countedOverride.counts.NO);
            }
            return formatYesPercent(counts.YES, counts.NO);
        }

        function renderVoteHistory() {
            const container = document.getElementById('vote-history-results');
            if (!container) return;

            if (!Array.isArray(voteHistorySessionsCache) || voteHistorySessionsCache.length === 0) {
                container.className = 'vote-history-message';
                container.textContent = 'Vote History is unavailable.';
                return;
            }

            const orderedSessions = [...voteHistorySessionsCache].sort((a, b) => {
                const ai = SESSION_ORDER_INDEX[a.id] !== undefined ? SESSION_ORDER_INDEX[a.id] : -1;
                const bi = SESSION_ORDER_INDEX[b.id] !== undefined ? SESSION_ORDER_INDEX[b.id] : -1;
                return bi - ai;
            });

            container.replaceChildren();
            container.className = 'vote-history-list';

            const headers = [
                'Night',
                'Date',
                'Vote Title',
                'Vote Description',
                'Yes',
                'No',
                'Abstain',
                'No Vote Recorded',
                'Vote Result',
                'Link 1',
                'Link 2',
                'Link 3',
                'Link 4'
            ];

            orderedSessions.forEach(session => {
                const detailsEl = document.createElement('details');
                detailsEl.className = 'vote-history-session';

                const summaryEl = document.createElement('summary');
                summaryEl.textContent = `${session.label} (${session.votes.length} votes)`;
                detailsEl.appendChild(summaryEl);

                const tableWrapEl = document.createElement('div');
                tableWrapEl.className = 'vote-history-table-wrap';

                const tableEl = document.createElement('table');
                tableEl.className = 'vote-history-table';

                const theadEl = document.createElement('thead');
                const headRowEl = document.createElement('tr');
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headRowEl.appendChild(th);
                });
                theadEl.appendChild(headRowEl);
                tableEl.appendChild(theadEl);

                const tbodyEl = document.createElement('tbody');
                session.votes.forEach(vote => {
                    const rowEl = document.createElement('tr');
                    const nightDate = splitNightDateLabel(vote.night || '');
                    const counts = computeVoteBreakdownFromSession(session, vote);
                    const links = Array.isArray(vote.links) ? vote.links : [];

                    const addTextCell = (text, className = '') => {
                        const td = document.createElement('td');
                        if (className) td.className = className;
                        td.textContent = text;
                        rowEl.appendChild(td);
                    };

                    addTextCell(nightDate.night || '—');
                    addTextCell(nightDate.date || '—');
                    addTextCell(vote.title || '');
                    addTextCell(vote.description || '—', 'description-col');
                    addTextCell(String(counts.YES), 'num-col');
                    addTextCell(String(counts.NO), 'num-col');
                    addTextCell(String(counts.ABSTAIN), 'num-col');
                    addTextCell(String(counts.NoVote), 'num-col');
                    addTextCell(vote.result || '—');

                    for (let i = 0; i < 4; i++) {
                        const td = document.createElement('td');
                        td.className = 'link-col';
                        const url = String(links[i] || '').trim();
                        if (/^https?:\/\//i.test(url)) {
                            const linkEl = document.createElement('a');
                            linkEl.href = url;
                            linkEl.target = '_blank';
                            linkEl.rel = 'noopener noreferrer';
                            linkEl.textContent = `Link ${i + 1}`;
                            td.appendChild(linkEl);
                        } else {
                            td.textContent = '—';
                        }
                        rowEl.appendChild(td);
                    }

                    tbodyEl.appendChild(rowEl);
                });

                tableEl.appendChild(tbodyEl);
                tableWrapEl.appendChild(tableEl);
                detailsEl.appendChild(tableWrapEl);
                container.appendChild(detailsEl);
            });
        }

        async function ensureVoteHistoryDataLoaded() {
            const container = document.getElementById('vote-history-results');
            if (!container) return;

            // Reuse already-loaded session data whenever possible.
            if (voteHistorySessionsCache) {
                renderVoteHistory();
                return;
            }

            if (clusteringSessionsCache) {
                voteHistorySessionsCache = clusteringSessionsCache;
                renderVoteHistory();
                return;
            }

            if (voteHistoryLoadPromise) {
                await voteHistoryLoadPromise;
                return;
            }
            // Avoid duplicate network fetches when another module is already loading all sessions.
            if (precinctVotesLoadPromise) {
                await precinctVotesLoadPromise;
                if (voteHistorySessionsCache) {
                    renderVoteHistory();
                    return;
                }
            }

            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                if (clusteringSessionsCache) {
                    voteHistorySessionsCache = clusteringSessionsCache;
                    renderVoteHistory();
                    return;
                }
            }

            let loadedCount = 0;
            const total = SESSION_FILES.length;
            container.className = 'vote-history-message';
            container.textContent = `Loading Vote History (0 of ${total})...`;

            // Fetch every configured session once, then cache for other cross-session modules.
            voteHistoryLoadPromise = Promise.all(
                SESSION_FILES.map(async session => {
                    try {
                        return await fetchAndParseSpreadsheet(session);
                    } catch (err) {
                        throw new Error(`${session.label}: ${err.message}`);
                    } finally {
                        loadedCount += 1;
                        container.textContent = `Loading Vote History (${loadedCount} of ${total})...`;
                    }
                })
            ).then(results => {
                voteHistorySessionsCache = results;
                if (!clusteringSessionsCache) clusteringSessionsCache = results;
                renderVoteHistory();
            }).catch(err => {
                console.error(err);
                container.className = 'vote-history-message';
                container.textContent = `Error loading Vote History: ${err.message}`;
            }).finally(() => {
                voteHistoryLoadPromise = null;
            });

            await voteHistoryLoadPromise;
        }

        function renderPrecinctVotes() {
            const container = document.getElementById('precinct-votes-results');
            if (!container) return;

            if (!Array.isArray(voteHistorySessionsCache) || voteHistorySessionsCache.length === 0) {
                container.className = 'vote-history-message';
                container.textContent = 'Precinct Votes is unavailable.';
                return;
            }

            const orderedSessions = [...voteHistorySessionsCache].sort((a, b) => {
                const ai = SESSION_ORDER_INDEX[a.id] !== undefined ? SESSION_ORDER_INDEX[a.id] : -1;
                const bi = SESSION_ORDER_INDEX[b.id] !== undefined ? SESSION_ORDER_INDEX[b.id] : -1;
                return bi - ai;
            });

            container.replaceChildren();
            container.className = 'precinct-votes-list';

            const headers = [
                'Vote Title',
                'Vote Description',
                'Vote Result',
                'All',
                ...STANDARD_PRECINCTS.map(precinct => `P${precinct}`)
            ];

            orderedSessions.forEach(session => {
                const detailsEl = document.createElement('details');
                detailsEl.className = 'vote-history-session';

                const summaryEl = document.createElement('summary');
                summaryEl.textContent = `${session.label} (${session.votes.length} votes)`;
                detailsEl.appendChild(summaryEl);

                const topScrollEl = document.createElement('div');
                topScrollEl.className = 'precinct-votes-scroll-top';
                const topScrollInnerEl = document.createElement('div');
                topScrollInnerEl.className = 'precinct-votes-scroll-inner';
                topScrollEl.appendChild(topScrollInnerEl);
                detailsEl.appendChild(topScrollEl);

                const tableWrapEl = document.createElement('div');
                tableWrapEl.className = 'precinct-votes-table-wrap';

                const tableEl = document.createElement('table');
                tableEl.className = 'precinct-votes-table';

                const theadEl = document.createElement('thead');
                const headRowEl = document.createElement('tr');
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headRowEl.appendChild(th);
                });
                theadEl.appendChild(headRowEl);
                tableEl.appendChild(theadEl);

                const tbodyEl = document.createElement('tbody');
                session.votes.forEach(vote => {
                    const rowEl = document.createElement('tr');
                    const counts = computeVoteBreakdownFromSession(session, vote);
                    const precinctPercentages = computePrecinctYesPercentages(session, vote);

                    const addCell = (text, className = '') => {
                        const td = document.createElement('td');
                        if (className) td.className = className;
                        td.textContent = text;
                        rowEl.appendChild(td);
                    };

                    addCell(vote.title || '');
                    addCell(vote.description || '—', 'description-col');
                    addCell(vote.result || '—');
                    addCell(getAggregateYesPercentForVote(session, vote, counts), 'aggregate-col');

                    STANDARD_PRECINCTS.forEach(precinct => {
                        addCell(precinctPercentages[precinct] || '—', 'pct-col');
                    });

                    tbodyEl.appendChild(rowEl);
                });

                tableEl.appendChild(tbodyEl);
                tableWrapEl.appendChild(tableEl);
                detailsEl.appendChild(tableWrapEl);
                container.appendChild(detailsEl);

                const syncTopScroll = () => {
                    // Top scrollbar mirrors the table scroller for easier horizontal navigation.
                    const fullWidth = Math.max(tableEl.scrollWidth, tableWrapEl.clientWidth);
                    topScrollInnerEl.style.width = `${fullWidth}px`;
                    topScrollEl.style.display = fullWidth > tableWrapEl.clientWidth ? 'block' : 'none';
                };

                let syncing = false;
                topScrollEl.addEventListener('scroll', () => {
                    if (syncing) return;
                    syncing = true;
                    tableWrapEl.scrollLeft = topScrollEl.scrollLeft;
                    syncing = false;
                });
                tableWrapEl.addEventListener('scroll', () => {
                    if (syncing) return;
                    syncing = true;
                    topScrollEl.scrollLeft = tableWrapEl.scrollLeft;
                    syncing = false;
                });

                detailsEl.addEventListener('toggle', () => {
                    if (detailsEl.open) syncTopScroll();
                });
                window.addEventListener('resize', syncTopScroll);
            });
        }

        async function ensurePrecinctVotesDataLoaded() {
            const container = document.getElementById('precinct-votes-results');
            if (!container) return;

            if (voteHistorySessionsCache) {
                renderPrecinctVotes();
                return;
            }

            if (clusteringSessionsCache) {
                voteHistorySessionsCache = clusteringSessionsCache;
                renderPrecinctVotes();
                return;
            }

            if (precinctVotesLoadPromise) {
                await precinctVotesLoadPromise;
                return;
            }

            // Reuse shared cache if Vote History or Clustering already loaded all sessions.
            if (voteHistoryLoadPromise) {
                await voteHistoryLoadPromise;
                if (voteHistorySessionsCache) {
                    renderPrecinctVotes();
                    return;
                }
            }

            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                if (clusteringSessionsCache) {
                    voteHistorySessionsCache = clusteringSessionsCache;
                    renderPrecinctVotes();
                    return;
                }
            }

            let loadedCount = 0;
            const total = SESSION_FILES.length;
            container.className = 'vote-history-message';
            container.textContent = `Loading Precinct Votes (0 of ${total})...`;

            precinctVotesLoadPromise = Promise.all(
                SESSION_FILES.map(async session => {
                    try {
                        return await fetchAndParseSpreadsheet(session);
                    } catch (err) {
                        throw new Error(`${session.label}: ${err.message}`);
                    } finally {
                        loadedCount += 1;
                        container.textContent = `Loading Precinct Votes (${loadedCount} of ${total})...`;
                    }
                })
            ).then(results => {
                voteHistorySessionsCache = results;
                if (!clusteringSessionsCache) clusteringSessionsCache = results;
                renderPrecinctVotes();
            }).catch(err => {
                console.error(err);
                container.className = 'vote-history-message';
                container.textContent = `Error loading Precinct Votes: ${err.message}`;
            }).finally(() => {
                precinctVotesLoadPromise = null;
            });

            await precinctVotesLoadPromise;
        }

        function computeContentiousYesFraction(counts, ignoreAbstainVotes) {
            const yes = Number(counts && counts.YES) || 0;
            const no = Number(counts && counts.NO) || 0;
            const abstain = Number(counts && counts.ABSTAIN) || 0;
            const denominator = ignoreAbstainVotes ? (yes + no) : (yes + no + abstain);
            if (denominator <= 0) return null;
            return yes / denominator;
        }

        function renderContentiousVotes() {
            const container = document.getElementById('contentious-votes-results');
            if (!container) return;

            if (!Array.isArray(voteHistorySessionsCache) || voteHistorySessionsCache.length === 0) {
                container.className = 'vote-history-message';
                container.textContent = 'Closest Votes is unavailable.';
                return;
            }

            const ignoreTerminateCheckbox = document.getElementById('contentious-ignore-terminate');
            const ignoreTerminate = ignoreTerminateCheckbox ? ignoreTerminateCheckbox.checked : true;
            const ignoreAbstain = true;

            const flattenedVotes = [];
            voteHistorySessionsCache.forEach(session => {
                const sessionOrder = getSessionOrderIndex(session.id);
                (session.votes || []).forEach((vote, voteIndex) => {
                    if (ignoreTerminate && vote && vote.isTerminateDebate) return;
                    const counts = computeVoteBreakdownFromSession(session, vote);
                    const yesFraction = computeContentiousYesFraction(counts, ignoreAbstain);
                    if (!Number.isFinite(yesFraction)) return;

                    flattenedVotes.push({
                        sessionLabel: session.label || 'Unknown Session',
                        sessionOrder,
                        voteIndex,
                        voteTitle: vote && vote.title ? vote.title : '',
                        voteDescription: vote && vote.description ? vote.description : '—',
                        yes: counts.YES,
                        no: counts.NO,
                        abstain: counts.ABSTAIN,
                        noVote: counts.NoVote,
                        result: vote && vote.result ? vote.result : '—',
                        distanceToEven: Math.abs(yesFraction - 0.5),
                        totalCast: counts.YES + counts.NO + counts.ABSTAIN
                    });
                });
            });

            flattenedVotes.sort((a, b) => {
                if (a.distanceToEven !== b.distanceToEven) return a.distanceToEven - b.distanceToEven;
                if (b.totalCast !== a.totalCast) return b.totalCast - a.totalCast;
                if (b.sessionOrder !== a.sessionOrder) return b.sessionOrder - a.sessionOrder;
                if (a.voteIndex !== b.voteIndex) return a.voteIndex - b.voteIndex;
                return a.voteTitle.localeCompare(b.voteTitle);
            });

            const topVotes = flattenedVotes.slice(0, 50);
            if (topVotes.length === 0) {
                container.className = 'vote-history-message';
                container.textContent = 'No votes match the current filters.';
                return;
            }

            container.replaceChildren();
            container.className = '';

            const summaryEl = document.createElement('div');
            summaryEl.className = 'vote-history-message';
            summaryEl.textContent = `Showing ${topVotes.length} votes closest to 50-50 split across all sessions.`;
            container.appendChild(summaryEl);

            const tableWrapEl = document.createElement('div');
            tableWrapEl.className = 'contentious-votes-table-wrap';

            const tableEl = document.createElement('table');
            tableEl.className = 'contentious-votes-table';

            const headers = [
                { text: 'Session', className: '' },
                { text: 'Vote Title', className: '' },
                { text: 'Vote Description', className: '' },
                { text: 'Yes', className: 'num-col' },
                { text: 'No', className: 'num-col' },
                { text: 'Abstain', className: 'num-col' },
                { text: 'No Vote Recorded', className: 'num-col' },
                { text: 'Vote Result', className: '' }
            ];

            const theadEl = document.createElement('thead');
            const headRowEl = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                if (header.className) th.className = header.className;
                th.textContent = header.text;
                headRowEl.appendChild(th);
            });
            theadEl.appendChild(headRowEl);
            tableEl.appendChild(theadEl);

            const tbodyEl = document.createElement('tbody');
            topVotes.forEach(entry => {
                const rowEl = document.createElement('tr');

                const addTextCell = (text, className = '') => {
                    const td = document.createElement('td');
                    if (className) td.className = className;
                    td.textContent = text;
                    rowEl.appendChild(td);
                };

                addTextCell(entry.sessionLabel);
                addTextCell(entry.voteTitle);
                addTextCell(entry.voteDescription, 'description-col');
                addTextCell(String(entry.yes), 'num-col');
                addTextCell(String(entry.no), 'num-col');
                addTextCell(String(entry.abstain), 'num-col');
                addTextCell(String(entry.noVote), 'num-col');
                addTextCell(entry.result);

                tbodyEl.appendChild(rowEl);
            });

            tableEl.appendChild(tbodyEl);
            tableWrapEl.appendChild(tableEl);
            container.appendChild(tableWrapEl);
        }

        async function ensureContentiousVotesDataLoaded() {
            const container = document.getElementById('contentious-votes-results');
            if (!container) return;

            if (voteHistorySessionsCache) {
                renderContentiousVotes();
                return;
            }

            if (clusteringSessionsCache) {
                voteHistorySessionsCache = clusteringSessionsCache;
                renderContentiousVotes();
                return;
            }

            if (contentiousVotesLoadPromise) {
                await contentiousVotesLoadPromise;
                return;
            }

            if (voteHistoryLoadPromise) {
                await voteHistoryLoadPromise;
                if (voteHistorySessionsCache) {
                    renderContentiousVotes();
                    return;
                }
            }

            if (precinctVotesLoadPromise) {
                await precinctVotesLoadPromise;
                if (voteHistorySessionsCache) {
                    renderContentiousVotes();
                    return;
                }
            }

            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                if (clusteringSessionsCache) {
                    voteHistorySessionsCache = clusteringSessionsCache;
                    renderContentiousVotes();
                    return;
                }
            }

            let loadedCount = 0;
            const total = SESSION_FILES.length;
            container.className = 'vote-history-message';
            container.textContent = `Loading Closest Votes (0 of ${total})...`;

            contentiousVotesLoadPromise = Promise.all(
                SESSION_FILES.map(async session => {
                    try {
                        return await fetchAndParseSpreadsheet(session);
                    } catch (err) {
                        throw new Error(`${session.label}: ${err.message}`);
                    } finally {
                        loadedCount += 1;
                        container.textContent = `Loading Closest Votes (${loadedCount} of ${total})...`;
                    }
                })
            ).then(results => {
                voteHistorySessionsCache = results;
                if (!clusteringSessionsCache) clusteringSessionsCache = results;
                renderContentiousVotes();
            }).catch(err => {
                console.error(err);
                container.className = 'vote-history-message';
                container.textContent = `Error loading Closest Votes: ${err.message}`;
            }).finally(() => {
                contentiousVotesLoadPromise = null;
            });

            await contentiousVotesLoadPromise;
        }

        /****************************************************
         * LOADING & PARSING EXCEL
         ****************************************************/

        function parseMemberAliasesRows(rows) {
            const aliasMap = new Map();
            const canonicalDisplayNames = new Map();
            if (!Array.isArray(rows) || rows.length === 0) {
                return { aliasMap, canonicalDisplayNames };
            }

            const firstCol = String(((rows[0] || [])[0]) || '').trim().toLowerCase();
            const secondCol = String(((rows[0] || [])[1]) || '').trim().toLowerCase();
            const hasHeaderRow =
                (firstCol.includes('canonical') || firstCol === 'name') &&
                secondCol.includes('alias');
            const startRow = hasHeaderRow ? 1 : 0;

            for (let r = startRow; r < rows.length; r++) {
                const row = rows[r] || [];
                const canonicalRaw = String(row[0] || '').trim();
                const aliasesRaw = String(row[1] || '').trim();
                if (!canonicalRaw) continue;

                const canonical = normalizeMemberAliasToken(canonicalRaw);
                if (!canonical) continue;
                if (!canonicalDisplayNames.has(canonical)) {
                    canonicalDisplayNames.set(canonical, canonicalRaw);
                }

                aliasMap.set(canonical, canonical);
                if (!aliasesRaw) continue;

                aliasesRaw
                    .split('::')
                    .map(token => normalizeMemberAliasToken(token))
                    .filter(Boolean)
                    .forEach(alias => aliasMap.set(alias, canonical));
            }

            return { aliasMap, canonicalDisplayNames };
        }

        async function ensureMemberAliasesLoaded() {
            if (memberAliasesLoadComplete) return;
            if (memberAliasesLoadPromise) {
                await memberAliasesLoadPromise;
                return;
            }

            memberAliasesLoadPromise = (async () => {
                const attemptErrors = [];
                const candidateFiles = buildMemberAliasesCandidateFiles();
                for (const aliasFile of candidateFiles) {
                    try {
                        const response = await fetch(getSpreadsheetRawURL(aliasFile));
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const arrayBuffer = await response.arrayBuffer();
                        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const sheet = workbook.Sheets[sheetName];
                        const rows = XLSX.utils.sheet_to_json(sheet, {
                            header: 1,
                            blankrows: false,
                            defval: ''
                        });
                        const parsedAliases = parseMemberAliasesRows(rows);
                        if (parsedAliases.aliasMap.size === 0) {
                            throw new Error('loaded but no alias rows were found');
                        }

                        const mergedAliases = new Map(DEFAULT_MEMBER_IDENTITY_ALIASES);
                        parsedAliases.aliasMap.forEach((canonical, alias) => mergedAliases.set(alias, canonical));
                        memberIdentityAliases = mergedAliases;
                        memberIdentityCanonicalDisplayNames = parsedAliases.canonicalDisplayNames;
                        memberAliasesLoadComplete = true;
                        return;
                    } catch (err) {
                        attemptErrors.push(`${aliasFile}: ${err && err.message ? err.message : 'load error'}`);
                    }
                }

                throw new Error(
                    `Unable to load members_aliases.xlsx from remote repository. ${attemptErrors.join(' | ') || 'No candidate paths found.'}`
                );
            })();

            try {
                await memberAliasesLoadPromise;
            } finally {
                memberAliasesLoadPromise = null;
            }
        }

        function parseVoteGuideRows(rows) {
            const index = new Map();
            const looseIndex = new Map();
            if (!rows || rows.length < 2) return { index, looseIndex };

            // Header matching is case-insensitive to tolerate workbook formatting drift.
            const headers = (rows[0] || []).map(cell => String(cell || '').trim().toLowerCase());
            const sessionCol = headers.findIndex(header => header === 'town meeting session');
            const nightCol = headers.findIndex(header => header.startsWith('night'));
            const voteCol = headers.findIndex(header => header === 'vote');
            const descriptionCol = headers.findIndex(header => header === 'description');
            const linkCols = headers
                .map((header, idx) => ({ header, idx }))
                .filter(entry => entry.header.startsWith('link'))
                .map(entry => entry.idx);

            if (sessionCol < 0 || voteCol < 0) return { index, looseIndex };

            for (let r = 1; r < rows.length; r++) {
                const row = rows[r] || [];
                const sessionLabel = String(row[sessionCol] || '').trim();
                const voteTitle = String(row[voteCol] || '').trim();
                if (!sessionLabel || !voteTitle) continue;

                const sessionId = getSessionIdFromGuideLabel(sessionLabel);
                if (!sessionId) continue;

                const description = descriptionCol >= 0 ? String(row[descriptionCol] || '').trim() : '';
                const night = nightCol >= 0 ? String(row[nightCol] || '').trim() : '';
                const links = linkCols
                    .map(colIndex => String(row[colIndex] || '').trim())
                    .filter(link => /^https?:\/\//i.test(link));

                const key = buildVoteGuideKey(sessionId, voteTitle);
                const mergeGuideEntry = (existing, incoming) => {
                    if (!existing) return incoming;
                    // Keep richer description and union links when guide has duplicate rows.
                    const mergedLinks = Array.from(new Set([...(existing.links || []), ...(incoming.links || [])]));
                    return {
                        description: (incoming.description.length > (existing.description || '').length)
                            ? incoming.description
                            : existing.description,
                        night: existing.night || incoming.night,
                        links: mergedLinks,
                        sessionLabel: existing.sessionLabel || incoming.sessionLabel
                    };
                };

                const incoming = { description, night, links, sessionLabel };
                index.set(key, mergeGuideEntry(index.get(key), incoming));

                const looseKey = buildLooseVoteGuideKey(sessionId, voteTitle);
                looseIndex.set(looseKey, mergeGuideEntry(looseIndex.get(looseKey), incoming));
            }

            return { index, looseIndex };
        }

        async function ensureVoteGuideLoaded() {
            if (voteGuideLoadComplete || voteGuideBySessionAndVote.size > 0) return;
            if (voteGuideLoadPromise) {
                await voteGuideLoadPromise;
                return;
            }

            voteGuideLoadPromise = (async () => {
                try {
                    let loadedFromFile = '';
                    const attemptErrors = [];
                    const candidateFiles = buildVoteGuideCandidateFiles();

                    // Try all candidate file paths; first valid parse wins.
                    for (const guideFile of candidateFiles) {
                        try {
                            const response = await fetch(getSpreadsheetRawURL(guideFile));
                            if (!response.ok) {
                                attemptErrors.push(`${guideFile}: HTTP ${response.status} ${response.statusText}`);
                                continue;
                            }

                            const arrayBuffer = await response.arrayBuffer();
                            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const sheet = workbook.Sheets[sheetName];
                            const rows = XLSX.utils.sheet_to_json(sheet, {
                                header: 1,
                                blankrows: false,
                                defval: ''
                            });

                            const parsedGuide = parseVoteGuideRows(rows);
                            if (parsedGuide.index.size === 0) {
                                attemptErrors.push(`${guideFile}: loaded but no valid VoteGuide rows were found`);
                                continue;
                            }

                            voteGuideBySessionAndVote = parsedGuide.index;
                            voteGuideBySessionAndLooseVote = parsedGuide.looseIndex;
                            loadedFromFile = guideFile;
                            break;
                        } catch (err) {
                            attemptErrors.push(`${guideFile}: ${err && err.message ? err.message : 'load error'}`);
                        }
                    }

                    if (!loadedFromFile) {
                        throw new Error(attemptErrors.join(' | ') || 'VoteGuide file not found');
                    }
                } catch (err) {
                    // Fail soft: app remains usable with base spreadsheet descriptions.
                    console.warn('VoteGuide could not be loaded; using spreadsheet descriptions only.', err);
                    voteGuideBySessionAndVote = new Map();
                    voteGuideBySessionAndLooseVote = new Map();
                } finally {
                    voteGuideLoadComplete = true;
                    voteGuideLoadPromise = null;
                }
            })();

            await voteGuideLoadPromise;
        }

        function parseRowsToData(rows, sessionMeta = {}) {
            if (!rows || rows.length <= HEADER_ROW_INDEX) {
                throw new Error('Spreadsheet does not contain expected header rows.');
            }

            LAST_VOTE_COL_INDEX = 100;
            const sessionId = sessionMeta.id || 'session';
            const sessionLabel = sessionMeta.label || 'Session';

            const titleRow = rows[TITLE_ROW_INDEX] || [];
            const descRow = rows[DESCRIPTION_ROW_INDEX] || [];

            const defaultHeaderRow = rows[HEADER_ROW_INDEX] || [];
            const possibleAltHeaderRow = rows[DESCRIPTION_ROW_INDEX] || [];
            const hasHeaderLabels = row =>
                String(row[PRECINCT_COL_INDEX] || '').trim().toUpperCase() === 'PRECINCT' &&
                String(row[NAME_COL_INDEX] || '').trim().toUpperCase() === 'NAME';
            const looksLikeDataRow = row => {
                const precinct = String(row[PRECINCT_COL_INDEX] || '').trim();
                const name = String(row[NAME_COL_INDEX] || '').trim();
                const upperPrecinct = precinct.toUpperCase();
                const precinctNum = parseInt(precinct, 10);
                const isNumericPrecinct = !isNaN(precinctNum);
                const isAL = upperPrecinct === 'AL';
                return !!name && (isNumericPrecinct || isAL);
            };

            let effectiveHeaderRowIndex = HEADER_ROW_INDEX;
            let effectiveFirstDataRowIndex = FIRST_DATA_ROW_INDEX;
            // Some sessions place the header one row higher; detect and shift safely.
            if (
                !hasHeaderLabels(defaultHeaderRow) &&
                hasHeaderLabels(possibleAltHeaderRow) &&
                looksLikeDataRow(defaultHeaderRow)
            ) {
                effectiveHeaderRowIndex = DESCRIPTION_ROW_INDEX;
                effectiveFirstDataRowIndex = HEADER_ROW_INDEX;
            }

            const headerRow = rows[effectiveHeaderRowIndex] || [];
            const maxPossibleCol = Math.max(titleRow.length, descRow.length, headerRow.length);

            let lastColWithTitle = FIRST_VOTE_COL_INDEX;
            for (let col = FIRST_VOTE_COL_INDEX; col < maxPossibleCol; col++) {
                const possibleTitle = String(titleRow[col] || headerRow[col] || '').trim();
                if (possibleTitle) {
                    lastColWithTitle = col;
                }
            }
            LAST_VOTE_COL_INDEX = lastColWithTitle;

            const parsedVotes = [];
            for (let col = FIRST_VOTE_COL_INDEX; col <= LAST_VOTE_COL_INDEX; col++) {
                const title = String(titleRow[col] || headerRow[col] || '').trim();
                if (!title) continue;
                // VoteGuide enriches description/night/links when available for this session+vote.
                const guideDetails = getVoteGuideDetails(sessionId, title);
                const descriptionFromSheet = String(descRow[col] || '').trim();
                parsedVotes.push({
                    id: `${sessionId}::${col}`,
                    sessionId,
                    sessionLabel,
                    colIndex: col,
                    title,
                    night: guideDetails ? String(guideDetails.night || '').trim() : '',
                    description: guideDetails && guideDetails.description
                        ? String(guideDetails.description).trim()
                        : descriptionFromSheet,
                    links: guideDetails && Array.isArray(guideDetails.links)
                        ? guideDetails.links
                        : [],
                    isTerminateDebate: isTerminateDebateVote(title)
                });
            }

            const parsedMembers = [];
            const parsedVotingData = {};
            const canonicalMembers = {};
            let lastMemberDataRowIndex = effectiveFirstDataRowIndex - 1;

            for (let r = effectiveFirstDataRowIndex; r < rows.length; r++) {
                const row = rows[r] || [];
                const name = String(row[NAME_COL_INDEX] || '').trim();
                const precinct = String(row[PRECINCT_COL_INDEX] || '').trim();

                if (!name && !precinct) continue;
                if (!name) continue;

                const upperName = name.toUpperCase();
                const upperPrecinct = precinct.toUpperCase();
                if (DISALLOWED_MEMBER_NAMES.has(upperName) || upperName.startsWith('TOTAL')) continue;

                const precinctNum = parseInt(precinct, 10);
                const isNumericPrecinct = !isNaN(precinctNum);
                const isAL = upperPrecinct === 'AL';
                if (!isNumericPrecinct && !isAL) continue;

                const memberKey = `${name} (Precinct ${precinct})`;
                const canonicalKey = canonicalMemberKey(name, precinct);
                const voteMapByTitle = {};
                const voteMapById = {};

                parsedVotes.forEach(vote => {
                    const normalized = normalizeVote(row[vote.colIndex]);
                    voteMapByTitle[vote.title] = normalized;
                    voteMapById[vote.id] = normalized;
                });

                parsedMembers.push({ name, precinct, key: memberKey });
                parsedVotingData[memberKey] = {
                    precinct,
                    votes: voteMapByTitle
                };
                lastMemberDataRowIndex = r;

                // Canonical key lets cross-session modules merge the same person reliably.
                const canonicalDisplayName = memberIdentityCanonicalDisplayNames.get(canonicalKey) || name;
                if (!canonicalMembers[canonicalKey]) {
                    canonicalMembers[canonicalKey] = {
                        name: canonicalDisplayName,
                        precinct,
                        memberKey,
                        votesById: voteMapById
                    };
                } else {
                    const existing = canonicalMembers[canonicalKey];
                    existing.name = memberIdentityCanonicalDisplayNames.get(canonicalKey) ||
                        preferDisplayName(existing.name, name);
                    if (String(existing.precinct || '').toUpperCase() !== 'AL' && String(precinct || '').toUpperCase() === 'AL') {
                        existing.precinct = precinct;
                    } else if (!existing.precinct && precinct) {
                        existing.precinct = precinct;
                    }

                    Object.entries(voteMapById).forEach(([voteId, voteValue]) => {
                        const existingVote = existing.votesById[voteId];
                        if (existingVote === undefined || existingVote === 'NoVote') {
                            existing.votesById[voteId] = voteValue;
                        }
                    });
                }
            }

            const voteResultsByCol = extractVoteResultsByColumn(
                rows,
                lastMemberDataRowIndex + 1,
                LAST_VOTE_COL_INDEX
            );
            parsedVotes.forEach(vote => {
                vote.result = voteResultsByCol[vote.colIndex] || '';
            });

            return {
                id: sessionId,
                label: sessionLabel,
                file: sessionMeta.file || '',
                votes: parsedVotes,
                members: parsedMembers,
                votingData: parsedVotingData,
                canonicalMembers
            };
        }

        function parseWorkbookArrayBuffer(arrayBuffer, sessionMeta = {}) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, {
                header: 1,
                blankrows: false,
                defval: ''
            });
            return parseRowsToData(rows, sessionMeta);
        }

        async function fetchAndParseSpreadsheet(sessionMeta) {
            await ensureMemberAliasesLoaded();
            const response = await fetch(getSpreadsheetRawURL(sessionMeta.file));
            if (!response.ok) {
                throw new Error(`HTTP ${response.status} ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            return parseWorkbookArrayBuffer(arrayBuffer, sessionMeta);
        }

        async function loadVotingDataFromExcel() {
            try {
                if (loadingEl) loadingEl.textContent = 'Loading voting data from spreadsheet...';
                await ensureVoteGuideLoaded();
                const parsed = await fetchAndParseSpreadsheet(getCurrentSpreadsheetMeta());

                votes = parsed.votes.map(vote => ({
                    colIndex: vote.colIndex,
                    title: vote.title,
                    description: vote.description,
                    links: vote.links || [],
                    night: vote.night || '',
                    result: vote.result || '',
                    isTerminateDebate: !!vote.isTerminateDebate
                }));
                members = parsed.members;
                votingData = parsed.votingData;

                // Rebuild UI from fresh in-memory state after every spreadsheet load.
                initializeApp();
            } catch (err) {
                console.error(err);
                if (loadingEl) loadingEl.textContent = `Error loading spreadsheet: ${err.message}`;
            }
        }

        /****************************************************
         * INITIALIZATION & DROPDOWNS
         ****************************************************/

        function initializeApp() {
            members.sort((a, b) => {
                const pa = precinctSortValue(a.precinct);
                const pb = precinctSortValue(b.precinct);
                if (pa !== pb) return pa - pb;
                return a.name.localeCompare(b.name);
            });

            populateDropdowns();

            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';

            if (votes.length > 0) {
                const voteSelect = document.getElementById('vote-select');
                if (voteSelect) voteSelect.value = votes[0].title;
                updateVoteResults();
            }

            const memberSelect = document.getElementById('member-select');
            if (memberSelect && memberSelect.value && votingData[memberSelect.value]) {
                updateMemberResults();
            }

            if (getActiveModuleId() === 'member-networks') {
                ensureMemberNetworkDataLoaded();
            }
        }

        function populateMemberDropdown() {
            const memberSelect = document.getElementById('member-select');
            if (!memberSelect) return;

            const sortByPrecinctCheckbox = document.getElementById('sort-by-precinct-member');
            const sortByPrecinct = sortByPrecinctCheckbox ? sortByPrecinctCheckbox.checked : false;
            const currentValue = memberSelect.value;
            const sortedMembers = [...members];

            sortedMembers.sort((a, b) => {
                if (sortByPrecinct) {
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                }
                return a.name.localeCompare(b.name);
            });

            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member.key;
                option.textContent = member.key;
                memberSelect.appendChild(option);
            });

            if (currentValue && Array.from(memberSelect.options).some(opt => opt.value === currentValue)) {
                memberSelect.value = currentValue;
            } else if (memberSelect.options.length > 0) {
                memberSelect.value = memberSelect.options[0].value;
            }
        }

        function populateDropdowns() {
            const voteSelect = document.getElementById('vote-select');
            if (!voteSelect) return;

            voteSelect.innerHTML = '';
            votes.forEach(vote => {
                const option = document.createElement('option');
                option.value = vote.title;
                option.textContent = vote.title;
                voteSelect.appendChild(option);
            });

            populateMemberDropdown();
        }

        function setSelectValueIfPresent(selectEl, value) {
            if (!selectEl) return false;
            const hasMatch = Array.from(selectEl.options).some(option => option.value === value);
            if (!hasMatch) return false;
            selectEl.value = value;
            return true;
        }

        function openMemberFromVoteView(memberKey) {
            const memberSelect = document.getElementById('member-select');
            if (!setSelectValueIfPresent(memberSelect, memberKey)) return;
            switchTab(null, 'by-member');
            updateMemberResults();
        }

        function openVoteFromMemberView(voteTitle) {
            const voteSelect = document.getElementById('vote-select');
            if (!setSelectValueIfPresent(voteSelect, voteTitle)) return;
            switchTab(null, 'by-vote');
            updateVoteResults();
        }

        /****************************************************
         * VIEW BY VOTE
         ****************************************************/

        function updateVoteResults() {
            const voteSelect = document.getElementById('vote-select');
            const sortByNameCheckbox = document.getElementById('sort-by-name-vote');
            if (!voteSelect || !sortByNameCheckbox) return;

            const selectedVote = voteSelect.value;
            const sortByNameOnly = sortByNameCheckbox.checked;
            const resultsDiv = document.getElementById('vote-results');
            if (!resultsDiv) return;

            const selectedVoteDetails = votes.find(v => v.title === selectedVote);
            const description = selectedVoteDetails ? selectedVoteDetails.description : '';
            const links = selectedVoteDetails && Array.isArray(selectedVoteDetails.links)
                ? selectedVoteDetails.links
                : [];
            const night = selectedVoteDetails ? selectedVoteDetails.night : '';
            const voteResult = selectedVoteDetails ? selectedVoteDetails.result : '';
            const currentSessionMeta = getCurrentSpreadsheetMeta();
            const sessionLabel = currentSessionMeta.label || '';
            const countedVoteOverride = getCountedVoteOverride(
                currentSessionMeta.id,
                selectedVoteDetails ? selectedVoteDetails.title : selectedVote
            );
            const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };

            members.forEach(member => {
                const voteVal = votingData[member.key].votes[selectedVote];
                const normalizedVote = voteVal ? voteVal.toUpperCase() : 'NOVOTE';
                if (normalizedVote === 'YES') {
                    voteGroups.YES.push(member);
                } else if (normalizedVote === 'NO') {
                    voteGroups.NO.push(member);
                } else if (normalizedVote === 'ABSTAIN') {
                    voteGroups.ABSTAIN.push(member);
                } else {
                    voteGroups.NoVote.push(member);
                }
            });

            Object.keys(voteGroups).forEach(voteType => {
                voteGroups[voteType].sort((a, b) => {
                    if (sortByNameOnly) return a.name.localeCompare(b.name);
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                    return a.name.localeCompare(b.name);
                });
            });

            const displayCounts = countedVoteOverride && countedVoteOverride.counts
                ? {
                    YES: Number(countedVoteOverride.counts.YES) || 0,
                    NO: Number(countedVoteOverride.counts.NO) || 0,
                    ABSTAIN: Number(countedVoteOverride.counts.ABSTAIN) || 0,
                    NoVote: Number(countedVoteOverride.counts.NoVote) || 0
                }
                : {
                    YES: voteGroups.YES.length,
                    NO: voteGroups.NO.length,
                    ABSTAIN: voteGroups.ABSTAIN.length,
                    NoVote: voteGroups.NoVote.length
                };

            const totalVotes = displayCounts.YES + displayCounts.NO;
            const percentages = {
                YES: totalVotes > 0 ? ((displayCounts.YES / totalVotes) * 100).toFixed(1) : '0.0',
                NO: totalVotes > 0 ? ((displayCounts.NO / totalVotes) * 100).toFixed(1) : '0.0'
            };

            resultsDiv.replaceChildren();

            if (selectedVoteDetails || description || links.length > 0) {
                const descriptionEl = document.createElement('div');
                descriptionEl.className = 'article-description';
                const summaryEl = document.createElement('div');
                summaryEl.className = 'article-summary-line';

                const summaryValues = [
                    { text: selectedVote || 'Vote title unavailable', className: 'article-summary-primary' },
                    { text: `Session: ${sessionLabel || 'Not listed'}` },
                    { text: `Night/Date: ${night || 'Not listed'}` },
                    { text: `Vote: ${voteResult || 'Not listed'}` }
                ];

                summaryValues.forEach((part, index) => {
                    const valueEl = document.createElement('span');
                    valueEl.textContent = part.text;
                    if (part.className) valueEl.className = part.className;
                    summaryEl.appendChild(valueEl);

                    if (index < summaryValues.length - 1) {
                        const sepEl = document.createElement('span');
                        sepEl.className = 'article-summary-separator';
                        sepEl.textContent = '•';
                        summaryEl.appendChild(sepEl);
                    }
                });
                descriptionEl.appendChild(summaryEl);

                if (description) {
                    const descriptionBodyEl = document.createElement('div');
                    descriptionBodyEl.textContent = description;
                    descriptionEl.appendChild(descriptionBodyEl);
                }

                const linksEl = buildArticleLinksElement(links);
                if (linksEl) {
                    descriptionEl.appendChild(linksEl);
                }

                if (countedVoteOverride && countedVoteOverride.detailLine) {
                    const countedLineEl = document.createElement('div');
                    countedLineEl.className = 'counted-vote-outcome';
                    countedLineEl.textContent = countedVoteOverride.detailLine;
                    descriptionEl.appendChild(countedLineEl);
                }
                resultsDiv.appendChild(descriptionEl);
            }

            const resultsGridEl = document.createElement('div');
            resultsGridEl.className = 'results';

            function appendMemberColumn(columnClass, title, memberList) {
                const columnEl = document.createElement('div');
                columnEl.className = `vote-column ${columnClass}`;

                const headerEl = document.createElement('h3');
                headerEl.textContent = title;
                columnEl.appendChild(headerEl);

                const listEl = document.createElement('div');
                listEl.className = 'member-list';

                memberList.forEach(member => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'member-item member-nav-target';
                    itemEl.setAttribute('role', 'button');
                    itemEl.tabIndex = 0;
                    itemEl.title = 'Open this member in View by Member';
                    itemEl.addEventListener('click', event => {
                        if (event.button !== 0) return;
                        openMemberFromVoteView(member.key);
                    });
                    itemEl.addEventListener('keydown', event => {
                        if (event.key !== 'Enter' && event.key !== ' ') return;
                        event.preventDefault();
                        openMemberFromVoteView(member.key);
                    });

                    const precinctEl = document.createElement('span');
                    precinctEl.className = 'precinct-label';
                    precinctEl.textContent = `${formatPrecinctLabel(member.precinct)}:`;
                    itemEl.appendChild(precinctEl);
                    itemEl.appendChild(document.createTextNode(` ${member.name}`));

                    listEl.appendChild(itemEl);
                });

                columnEl.appendChild(listEl);
                resultsGridEl.appendChild(columnEl);
            }

            appendMemberColumn('yes', `Yes (${displayCounts.YES}, ${percentages.YES}%)`, voteGroups.YES);
            appendMemberColumn('no', `No (${displayCounts.NO}, ${percentages.NO}%)`, voteGroups.NO);
            appendMemberColumn('abstain', `Abstain (${displayCounts.ABSTAIN})`, voteGroups.ABSTAIN);
            appendMemberColumn('novote', `Vote Not Recorded (${displayCounts.NoVote})`, voteGroups.NoVote);

            resultsDiv.appendChild(resultsGridEl);
        }

        /****************************************************
         * VIEW BY MEMBER
         ****************************************************/

        function updateMemberResults() {
            const memberSelect = document.getElementById('member-select');
            if (!memberSelect) return;

            const selectedMember = memberSelect.value;
            const resultsDiv = document.getElementById('member-results');
            if (!resultsDiv) return;
            if (!selectedMember || !votingData[selectedMember]) return;

            const memberVotes = votingData[selectedMember].votes;
            const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };

            votes.forEach(vote => {
                const voteValue = memberVotes[vote.title];
                const normalizedVote = voteValue ? voteValue.toUpperCase() : 'NOVOTE';
                const voteWithDesc = {
                    title: vote.title,
                    description: vote.description,
                    result: vote.result || '',
                    links: vote.links || []
                };
                if (normalizedVote === 'YES') {
                    voteGroups.YES.push(voteWithDesc);
                } else if (normalizedVote === 'NO') {
                    voteGroups.NO.push(voteWithDesc);
                } else if (normalizedVote === 'ABSTAIN') {
                    voteGroups.ABSTAIN.push(voteWithDesc);
                } else {
                    voteGroups.NoVote.push(voteWithDesc);
                }
            });

            const sortByArticle = (a, b) => {
                const aIsTerminate = a.title.toLowerCase().includes('terminate debate');
                const bIsTerminate = b.title.toLowerCase().includes('terminate debate');
                if (aIsTerminate && !bIsTerminate) return 1;
                if (!aIsTerminate && bIsTerminate) return -1;

                const aMatch = a.title.match(/Article (\d+)/i);
                const bMatch = b.title.match(/Article (\d+)/i);
                if (aMatch && bMatch) return parseInt(aMatch[1], 10) - parseInt(bMatch[1], 10);
                return a.title.localeCompare(b.title);
            };

            Object.keys(voteGroups).forEach(voteType => {
                voteGroups[voteType].sort(sortByArticle);
            });

            const total = votes.length;
            const percentages = {
                YES: total > 0 ? ((voteGroups.YES.length / total) * 100).toFixed(1) : '0.0',
                NO: total > 0 ? ((voteGroups.NO.length / total) * 100).toFixed(1) : '0.0',
                ABSTAIN: total > 0 ? ((voteGroups.ABSTAIN.length / total) * 100).toFixed(1) : '0.0',
                NoVote: total > 0 ? ((voteGroups.NoVote.length / total) * 100).toFixed(1) : '0.0'
            };

            resultsDiv.replaceChildren();

            function appendArticleColumn(columnClass, title, voteList) {
                const columnEl = document.createElement('div');
                columnEl.className = `vote-column ${columnClass}`;

                const headerEl = document.createElement('h3');
                headerEl.textContent = title;
                columnEl.appendChild(headerEl);

                const listEl = document.createElement('div');
                listEl.className = 'article-list';

                voteList.forEach(vote => {
                    const wrapperEl = document.createElement('div');
                    wrapperEl.className = 'article-item-with-desc';

                    const detailsEl = document.createElement('details');
                    detailsEl.className = 'article-detail';

                    const titleEl = document.createElement('summary');
                    titleEl.className = 'article-title article-title-toggle';
                    titleEl.textContent = vote.title;
                    titleEl.title = 'Open this vote in View by Vote';
                    titleEl.addEventListener('click', event => {
                        if (event.button !== 0) return;
                        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
                        event.preventDefault();
                        openVoteFromMemberView(vote.title);
                    });
                    detailsEl.appendChild(titleEl);

                    const detailBodyEl = document.createElement('div');
                    detailBodyEl.className = 'article-detail-body';

                    if (vote.result) {
                        const resultEl = document.createElement('div');
                        resultEl.className = 'article-vote-result';
                        resultEl.textContent = `Vote: ${vote.result}`;
                        detailBodyEl.appendChild(resultEl);
                    }

                    if (vote.description) {
                        const descEl = document.createElement('div');
                        descEl.className = 'article-desc';
                        descEl.textContent = vote.description;
                        detailBodyEl.appendChild(descEl);
                    }

                    const linksEl = buildArticleLinksElement(vote.links);
                    if (linksEl) {
                        detailBodyEl.appendChild(linksEl);
                    }

                    detailsEl.appendChild(detailBodyEl);
                    wrapperEl.appendChild(detailsEl);

                    listEl.appendChild(wrapperEl);
                });

                columnEl.appendChild(listEl);
                resultsDiv.appendChild(columnEl);
            }

            appendArticleColumn('yes', `Yes (${voteGroups.YES.length}, ${percentages.YES}%)`, voteGroups.YES);
            appendArticleColumn('no', `No (${voteGroups.NO.length}, ${percentages.NO}%)`, voteGroups.NO);
            appendArticleColumn('abstain', `Abstain (${voteGroups.ABSTAIN.length}, ${percentages.ABSTAIN}%)`, voteGroups.ABSTAIN);
            appendArticleColumn('novote', `Vote Not Recorded (${voteGroups.NoVote.length}, ${percentages.NoVote}%)`, voteGroups.NoVote);
        }

        /****************************************************
         * MEMBER NETWORKS
         ****************************************************/

        function setMemberNetworkStatus(message, isError = false, allowHtml = false) {
            if (!memberNetworkStatusEl) return;
            if (allowHtml) {
                memberNetworkStatusEl.innerHTML = message;
            } else {
                memberNetworkStatusEl.textContent = message;
            }
            memberNetworkStatusEl.classList.toggle('error', isError);
        }

        function isComparableVoteValue(voteValue) {
            return voteValue === 'YES' || voteValue === 'NO' || voteValue === 'ABSTAIN';
        }

        function memberCastRecordedVote(votesById) {
            return Object.values(votesById || {}).some(voteValue => isComparableVoteValue(voteValue));
        }

        function countSharedSessions(aSessions, bSessions) {
            if (!aSessions || !bSessions) return 0;
            const first = aSessions.size <= bSessions.size ? aSessions : bSessions;
            const second = first === aSessions ? bSessions : aSessions;
            let shared = 0;
            first.forEach(sessionId => {
                if (second.has(sessionId)) shared += 1;
            });
            return shared;
        }

        function getDefaultMemberNetworkSortDirection(sortKey) {
            if (sortKey === 'similarity' || sortKey === 'sharedSessions') return 'desc';
            return 'asc';
        }

        function setMemberNetworkSort(sortKey) {
            if (!sortKey) return;
            if (memberNetworkSortState.key === sortKey) {
                memberNetworkSortState.direction = memberNetworkSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                memberNetworkSortState.key = sortKey;
                memberNetworkSortState.direction = getDefaultMemberNetworkSortDirection(sortKey);
            }
            if (memberNetworkCurrentData) renderMemberNetworkNeighbors(memberNetworkCurrentData);
        }

        function sortMemberNetworkComparisons(comparisons) {
            const rows = (comparisons || []).map((entry, index) => ({
                ...entry,
                baseRank: index + 1
            }));
            const sortKey = memberNetworkSortState.key || 'baseRank';
            const direction = memberNetworkSortState.direction === 'desc' ? -1 : 1;

            rows.sort((a, b) => {
                let cmp = 0;

                if (sortKey === 'baseRank') {
                    cmp = a.baseRank - b.baseRank;
                } else if (sortKey === 'name') {
                    const lastA = getLastNameForSort(a.profile.name);
                    const lastB = getLastNameForSort(b.profile.name);
                    cmp = lastA.localeCompare(lastB);
                    if (cmp === 0) cmp = a.profile.name.localeCompare(b.profile.name);
                } else if (sortKey === 'precinct') {
                    const pa = precinctSortValue(a.profile.precinct);
                    const pb = precinctSortValue(b.profile.precinct);
                    cmp = pa - pb;
                    if (cmp === 0) cmp = a.profile.name.localeCompare(b.profile.name);
                } else if (sortKey === 'sharedSessions') {
                    cmp = a.sharedSessions - b.sharedSessions;
                } else if (sortKey === 'similarity') {
                    cmp = a.similarity - b.similarity;
                }

                // Deterministic tiebreaker: preserve original ranking order.
                if (cmp === 0) cmp = a.baseRank - b.baseRank;
                return cmp * direction;
            });

            return rows;
        }

        function computeSimilarityOnVoteIds(sourceVotesById, candidateVotesById, voteIds, ignoreAbstainVotes = false) {
            let overlap = 0;
            let exactMatches = 0;
            let similaritySum = 0;

            voteIds.forEach(voteId => {
                const a = sourceVotesById[voteId];
                const b = candidateVotesById[voteId];
                if (!isComparableVoteValue(a) || !isComparableVoteValue(b)) return;
                if (ignoreAbstainVotes && (a === 'ABSTAIN' || b === 'ABSTAIN')) return;

                const aNumeric = voteToNumeric(a);
                const bNumeric = voteToNumeric(b);
                if (!Number.isFinite(aNumeric) || !Number.isFinite(bNumeric)) return;

                overlap += 1;
                if (a === b) exactMatches += 1;
                similaritySum += 1 - (Math.abs(aNumeric - bNumeric) / 2);
            });

            if (overlap === 0) return null;
            return {
                overlap,
                exactMatches,
                similarity: similaritySum / overlap
            };
        }

        function cacheMemberNetworkProfilesFromSessions(sessionDataList) {
            const profileMap = new Map();

            (sessionDataList || []).forEach(session => {
                if (!session) return;
                const sessionOrder = getSessionOrderIndex(session.id);

                const voteMetaById = {};
                (session.votes || []).forEach(vote => {
                    voteMetaById[vote.id] = vote;
                });

                Object.entries(session.canonicalMembers || {}).forEach(([canonicalKey, memberEntry]) => {
                    if (!profileMap.has(canonicalKey)) {
                        profileMap.set(canonicalKey, {
                            canonicalKey,
                            name: memberEntry.name,
                            precinct: memberEntry.precinct,
                            precincts: new Set(),
                            memberLabel: memberEntry.name,
                            latestPrecinct: '',
                            latestSessionOrder: -1,
                            sessions: new Set(),
                            votesById: {},
                            voteMetaById: {}
                        });
                    }

                    const profile = profileMap.get(canonicalKey);
                    profile.name = preferDisplayName(profile.name, memberEntry.name);
                    if (memberEntry.precinct) profile.precincts.add(memberEntry.precinct);
                    if (sessionOrder >= profile.latestSessionOrder && memberEntry.precinct) {
                        profile.latestSessionOrder = sessionOrder;
                        profile.latestPrecinct = memberEntry.precinct;
                    }
                    profile.precinct = profile.latestPrecinct || summarizePrecinctSet(profile.precincts);
                    profile.memberLabel = profile.name;
                    if (memberCastRecordedVote(memberEntry.votesById)) {
                        profile.sessions.add(session.id);
                    }

                    Object.entries(memberEntry.votesById || {}).forEach(([voteId, voteValue]) => {
                        profile.votesById[voteId] = voteValue;
                        if (voteMetaById[voteId]) profile.voteMetaById[voteId] = voteMetaById[voteId];
                    });
                });
            });

            memberNetworkProfilesCache = Array.from(profileMap.values());
            memberNetworkProfileByKey = new Map(
                memberNetworkProfilesCache.map(profile => [profile.canonicalKey, profile])
            );
        }

        async function ensureMemberNetworkDataLoaded() {
            if (memberNetworkProfilesCache && memberNetworkProfilesCache.length > 0) {
                populateMemberNetworkDropdown();
                if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                return;
            }
            if (memberNetworkLoadPromise) {
                await memberNetworkLoadPromise;
                return;
            }

            if (clusteringSessionsCache) {
                cacheMemberNetworkProfilesFromSessions(clusteringSessionsCache);
                populateMemberNetworkDropdown();
                if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                return;
            }
            if (voteHistorySessionsCache) {
                cacheMemberNetworkProfilesFromSessions(voteHistorySessionsCache);
                populateMemberNetworkDropdown();
                if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                return;
            }

            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                if (clusteringSessionsCache) {
                    cacheMemberNetworkProfilesFromSessions(clusteringSessionsCache);
                    populateMemberNetworkDropdown();
                    if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                    return;
                }
            }
            if (voteHistoryLoadPromise) {
                await voteHistoryLoadPromise;
                if (voteHistorySessionsCache) {
                    cacheMemberNetworkProfilesFromSessions(voteHistorySessionsCache);
                    populateMemberNetworkDropdown();
                    if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                    return;
                }
            }
            if (precinctVotesLoadPromise) {
                await precinctVotesLoadPromise;
                if (voteHistorySessionsCache) {
                    cacheMemberNetworkProfilesFromSessions(voteHistorySessionsCache);
                    populateMemberNetworkDropdown();
                    if (getActiveModuleId() === 'member-networks') updateMemberNetworkResults();
                    return;
                }
            }

            let loadedCount = 0;
            const total = SESSION_FILES.length;
            setMemberNetworkStatus(`Loading member network data (0 of ${total})...`);
            setPanelMessage(memberNetworkNeighborsEl, 'Loading all sessions for member network analysis...');

            memberNetworkLoadPromise = (async () => {
                try {
                    await ensureVoteGuideLoaded();
                    const sessions = await Promise.all(
                        SESSION_FILES.map(async session => {
                            try {
                                return await fetchAndParseSpreadsheet(session);
                            } finally {
                                loadedCount += 1;
                                setMemberNetworkStatus(`Loading member network data (${loadedCount} of ${total})...`);
                            }
                        })
                    );

                    if (!voteHistorySessionsCache) voteHistorySessionsCache = sessions;
                    if (!clusteringSessionsCache) clusteringSessionsCache = sessions;

                    cacheMemberNetworkProfilesFromSessions(sessions);
                    populateMemberNetworkDropdown();
                    updateMemberNetworkResults();
                } catch (err) {
                    console.error(err);
                    memberNetworkProfilesCache = null;
                    memberNetworkProfileByKey = new Map();
                    setMemberNetworkStatus(`Error loading member network data: ${err.message}`, true);
                    setPanelMessage(memberNetworkNeighborsEl, 'Member network data failed to load.');
                } finally {
                    memberNetworkLoadPromise = null;
                }
            })();

            await memberNetworkLoadPromise;
        }

        function populateMemberNetworkDropdown() {
            const memberSelect = document.getElementById('member-network-select');
            if (!memberSelect) return;
            if (!Array.isArray(memberNetworkProfilesCache) || memberNetworkProfilesCache.length === 0) {
                memberSelect.replaceChildren();
                return;
            }

            const sortByPrecinctCheckbox = document.getElementById('sort-by-precinct-network');
            const sortByPrecinct = sortByPrecinctCheckbox ? sortByPrecinctCheckbox.checked : true;
            const currentValue = memberSelect.value;
            const sortedMembers = [...memberNetworkProfilesCache];

            sortedMembers.sort((a, b) => {
                if (sortByPrecinct) {
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                }

                const lastA = getLastNameForSort(a.name);
                const lastB = getLastNameForSort(b.name);
                if (lastA !== lastB) return lastA.localeCompare(lastB);
                return a.name.localeCompare(b.name);
            });

            memberSelect.replaceChildren();
            sortedMembers.forEach(memberProfile => {
                const option = document.createElement('option');
                option.value = memberProfile.canonicalKey;
                const precinctLabel = memberProfile.precinct
                    ? formatPrecinctLabel(memberProfile.precinct)
                    : 'MULTI';
                option.textContent =
                    `${memberProfile.memberLabel} (${precinctLabel}) - ${memberProfile.sessions.size} sessions`;
                memberSelect.appendChild(option);
            });

            if (currentValue && Array.from(memberSelect.options).some(opt => opt.value === currentValue)) {
                memberSelect.value = currentValue;
            } else if (memberSelect.options.length > 0) {
                memberSelect.value = memberSelect.options[0].value;
            }
        }

        function buildMemberNetworkData(selectedMemberKey, ignoreTerminateDebate, ignoreAbstainVotes = false) {
            if (!selectedMemberKey || !memberNetworkProfileByKey.has(selectedMemberKey)) return null;
            const selectedProfile = memberNetworkProfileByKey.get(selectedMemberKey);
            const selectedSessionCount = selectedProfile.sessions ? selectedProfile.sessions.size : 0;

            if (selectedSessionCount < 4) {
                return {
                    selectedProfile,
                    selectedMemberKey,
                    insufficientData: true,
                    comparisons: [],
                    eligibleVoteIds: [],
                    eligibleVoteCount: 0
                };
            }

            const eligibleVoteIds = Object.keys(selectedProfile.votesById).filter(voteId => {
                const voteValue = selectedProfile.votesById[voteId];
                if (!isComparableVoteValue(voteValue)) return false;
                if (ignoreAbstainVotes && voteValue === 'ABSTAIN') return false;

                if (ignoreTerminateDebate) {
                    const meta = selectedProfile.voteMetaById[voteId];
                    if (meta && meta.isTerminateDebate) return false;
                }
                return true;
            });

            const comparisons = [];
            memberNetworkProfilesCache.forEach(candidateProfile => {
                if (candidateProfile.canonicalKey === selectedMemberKey) return;
                const sharedSessions = countSharedSessions(selectedProfile.sessions, candidateProfile.sessions);
                if (sharedSessions < 4) return;

                const similarityData = computeSimilarityOnVoteIds(
                    selectedProfile.votesById,
                    candidateProfile.votesById,
                    eligibleVoteIds,
                    ignoreAbstainVotes
                );
                if (!similarityData) return;

                comparisons.push({
                    profile: candidateProfile,
                    overlap: similarityData.overlap,
                    exactMatches: similarityData.exactMatches,
                    similarity: similarityData.similarity,
                    coverage: eligibleVoteIds.length > 0 ? similarityData.overlap / eligibleVoteIds.length : 0,
                    sharedSessions
                });
            });

            comparisons.sort((a, b) => {
                if (b.similarity !== a.similarity) return b.similarity - a.similarity;
                if (b.overlap !== a.overlap) return b.overlap - a.overlap;
                if (b.sharedSessions !== a.sharedSessions) return b.sharedSessions - a.sharedSessions;
                return a.profile.name.localeCompare(b.profile.name);
            });

            return {
                selectedProfile,
                selectedMemberKey,
                insufficientData: false,
                eligibleVoteIds,
                eligibleVoteCount: eligibleVoteIds.length,
                comparisons
            };
        }

        function renderMemberNetworkNeighbors(networkData) {
            if (!memberNetworkNeighborsEl) return;

            if (!networkData || networkData.comparisons.length === 0) {
                setPanelMessage(memberNetworkNeighborsEl, 'No members share at least 4 sessions with this member.');
                return;
            }

            const sortedRows = sortMemberNetworkComparisons(networkData.comparisons);
            const sortKey = memberNetworkSortState.key;
            const sortDirection = memberNetworkSortState.direction;
            const wrapper = document.createElement('div');
            wrapper.className = 'member-network-table-wrap';

            const table = document.createElement('table');
            table.className = 'member-network-table';

            const thead = document.createElement('thead');
            const headRow = document.createElement('tr');
            const headerDefs = [
                { label: 'Rank', key: 'baseRank', className: 'rank-col' },
                { label: 'Member', key: 'name', className: 'member-col' },
                { label: 'Precinct', key: 'precinct', className: 'precinct-col' },
                { label: 'Shared Sessions', key: 'sharedSessions', className: 'shared-col' },
                { label: 'Similarity', key: 'similarity', className: 'sim-col' }
            ];

            headerDefs.forEach(def => {
                const th = document.createElement('th');
                th.className = def.className;

                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'member-network-sort-btn';
                const indicator = sortKey === def.key ? (sortDirection === 'asc' ? ' ▲' : ' ▼') : '';
                button.textContent = `${def.label}${indicator}`;
                button.addEventListener('click', () => setMemberNetworkSort(def.key));
                th.appendChild(button);
                headRow.appendChild(th);
            });
            thead.appendChild(headRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            sortedRows.forEach(entry => {
                const row = document.createElement('tr');
                const similarityPct = (entry.similarity * 100).toFixed(1);

                const rankCell = document.createElement('td');
                rankCell.className = 'rank-col';
                rankCell.textContent = `${entry.baseRank}`;

                const nameCell = document.createElement('td');
                nameCell.className = 'member-col';
                nameCell.textContent = entry.profile.name;

                const precinctCell = document.createElement('td');
                precinctCell.className = 'precinct-col';
                precinctCell.textContent = formatPrecinctLabel(entry.profile.precinct);

                const sharedSessionsCell = document.createElement('td');
                sharedSessionsCell.className = 'shared-col';
                sharedSessionsCell.textContent = String(entry.sharedSessions);

                const similarityCell = document.createElement('td');
                similarityCell.className = 'sim-col';
                similarityCell.textContent = `${similarityPct}%`;

                row.appendChild(rankCell);
                row.appendChild(nameCell);
                row.appendChild(precinctCell);
                row.appendChild(sharedSessionsCell);
                row.appendChild(similarityCell);
                tbody.appendChild(row);
            });

            table.appendChild(tbody);
            wrapper.appendChild(table);
            memberNetworkNeighborsEl.replaceChildren(wrapper);
        }

        async function updateMemberNetworkResults() {
            const memberSelect = document.getElementById('member-network-select');
            const ignoreTerminateCheckbox = document.getElementById('member-network-ignore-terminate');
            const ignoreAbstainCheckbox = document.getElementById('member-network-ignore-abstain');
            if (!memberSelect || !ignoreTerminateCheckbox || !ignoreAbstainCheckbox) return;

            if (!memberNetworkProfilesCache || memberNetworkProfilesCache.length === 0) {
                await ensureMemberNetworkDataLoaded();
                if (!memberNetworkProfilesCache || memberNetworkProfilesCache.length === 0) return;
            }

            if (memberSelect.options.length === 0) {
                populateMemberNetworkDropdown();
            }
            if (memberSelect.options.length === 0) {
                setMemberNetworkStatus('No members were found in the available Town Meeting sessions.', true);
                setPanelMessage(memberNetworkNeighborsEl, 'No members were found in the available sessions.');
                memberNetworkCurrentData = null;
                return;
            }

            const selectedMemberKey = memberSelect.value;
            if (!selectedMemberKey) {
                setMemberNetworkStatus('Select a member to view nearest voting neighbors.');
                setPanelMessage(memberNetworkNeighborsEl, 'Select a member to compute voting similarity.');
                memberNetworkCurrentData = null;
                return;
            }

            const networkData = buildMemberNetworkData(
                selectedMemberKey,
                ignoreTerminateCheckbox.checked,
                ignoreAbstainCheckbox.checked
            );
            if (!networkData) {
                setMemberNetworkStatus('Member comparison data is unavailable for the selected member.', true);
                setPanelMessage(memberNetworkNeighborsEl, 'Member comparison data is unavailable.');
                memberNetworkCurrentData = null;
                return;
            }

            if (networkData.insufficientData) {
                setMemberNetworkStatus('Not enough data to generate network.');
                setPanelMessage(memberNetworkNeighborsEl, 'Not enough data to generate network.');
                memberNetworkCurrentData = null;
                return;
            }

            if (networkData.eligibleVoteCount === 0) {
                setMemberNetworkStatus(
                    'No YES/NO/ABSTAIN votes are available for the selected member after current filters.'
                );
                setPanelMessage(
                    memberNetworkNeighborsEl,
                    'Try a different member or disable one of the ignore filters.'
                );
                memberNetworkCurrentData = null;
                return;
            }

            if (networkData.comparisons.length === 0) {
                setMemberNetworkStatus('Not enough overlapping data to generate network.');
                setPanelMessage(memberNetworkNeighborsEl, 'No members share at least 4 sessions with this member.');
                memberNetworkCurrentData = null;
                return;
            }

            const neighborCount = networkData.comparisons.length;
            const averageSimilarity = neighborCount > 0
                ? networkData.comparisons.reduce((sum, entry) => sum + entry.similarity, 0) / neighborCount
                : 0;
            setMemberNetworkStatus(
                `${networkData.selectedProfile.name}: showing ${neighborCount} qualifying similar members ` +
                `(minimum 4 shared sessions), average similarity <strong>${(averageSimilarity * 100).toFixed(1)}%</strong>.`,
                false,
                true
            );
            memberNetworkCurrentData = networkData;
            renderMemberNetworkNeighbors(networkData);
        }

        /****************************************************
         * VOTER CLUSTERING — DATA LOADING
         ****************************************************/

        function setClusteringStatus(message, isError = false) {
            if (!clusterStatusEl) return;
            clusterStatusEl.textContent = message;
            clusterStatusEl.classList.toggle('error', isError);
        }

        function setPanelMessage(panelEl, message) {
            if (!panelEl) return;
            panelEl.replaceChildren();
            const msg = document.createElement('div');
            msg.className = 'cluster-message';
            msg.textContent = message;
            panelEl.appendChild(msg);
        }

        function clearClusterPlot() {
            if (!clusterPlotEl || typeof Plotly === 'undefined') return;
            try {
                Plotly.purge(clusterPlotEl);
            } catch (err) {
                console.warn('Unable to clear clustering plot:', err);
            }
        }

        function initializeClusteringControls() {
            if (clusteringControlsInitialized) return;

            const sessionsContainer = document.getElementById('cluster-session-checkboxes');
            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            const terminateWeightSlider = document.getElementById('cluster-terminate-weight');
            const terminateWeightValue = document.getElementById('cluster-terminate-weight-value');
            const colorBySelect = document.getElementById('cluster-color-by');
            const memberSearchInput = document.getElementById('cluster-member-search');
            const memberSearchButton = document.getElementById('cluster-member-search-go');

            if (
                !sessionsContainer ||
                !minSessionsSelect ||
                !terminateWeightSlider ||
                !terminateWeightValue ||
                !colorBySelect ||
                !memberSearchInput ||
                !memberSearchButton
            ) {
                return;
            }

            const defaultSelectedSessionCount = Math.min(4, SESSION_FILES.length);
            const defaultMinimumSessions = Math.min(4, SESSION_FILES.length);

            [...SESSION_FILES].reverse().forEach((session, index) => {
                const optionLabel = document.createElement('label');
                optionLabel.className = 'session-option';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = index < defaultSelectedSessionCount;
                checkbox.value = session.id;
                checkbox.setAttribute('data-session-id', session.id);

                const text = document.createElement('span');
                text.textContent = session.label;

                optionLabel.appendChild(checkbox);
                optionLabel.appendChild(text);
                sessionsContainer.appendChild(optionLabel);
            });

            minSessionsSelect.replaceChildren();
            for (let i = 1; i <= SESSION_FILES.length; i++) {
                const option = document.createElement('option');
                option.value = String(i);
                option.textContent = String(i);
                if (i === defaultMinimumSessions) option.selected = true;
                minSessionsSelect.appendChild(option);
            }

            terminateWeightSlider.value = '0';
            terminateWeightValue.textContent = Number.parseFloat(terminateWeightSlider.value).toFixed(1);
            colorBySelect.value = 'none';

            sessionsContainer.addEventListener('change', event => {
                if (event.target && event.target.matches('input[type="checkbox"]')) {
                    syncMinimumSessionsControl();
                    runClusteringAnalysis();
                }
            });

            minSessionsSelect.addEventListener('change', runClusteringAnalysis);
            colorBySelect.addEventListener('change', runClusteringAnalysis);
            terminateWeightSlider.addEventListener('input', () => {
                terminateWeightValue.textContent = Number.parseFloat(terminateWeightSlider.value).toFixed(1);
                debouncedRunClusteringAnalysis();
            });

            memberSearchButton.addEventListener('click', selectClusterMemberFromSearch);
            memberSearchInput.addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    selectClusterMemberFromSearch();
                }
            });

            clusteringControlsInitialized = true;
            syncMinimumSessionsControl();
        }

        function getSelectedClusteringSessionIds() {
            const checked = document.querySelectorAll('#cluster-session-checkboxes input[type="checkbox"]:checked');
            return new Set(Array.from(checked).map(input => input.value));
        }

        function syncMinimumSessionsControl() {
            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            if (!minSessionsSelect) return;

            const selectedCount = getSelectedClusteringSessionIds().size;
            const maxAllowed = Math.max(1, selectedCount);
            const current = Number.parseInt(minSessionsSelect.value, 10) || 1;

            Array.from(minSessionsSelect.options).forEach(option => {
                const value = Number.parseInt(option.value, 10);
                option.disabled = value > maxAllowed;
            });

            if (current > maxAllowed) {
                minSessionsSelect.value = String(maxAllowed);
            }
        }

        function debouncedRunClusteringAnalysis() {
            if (clusteringDebounceTimer) clearTimeout(clusteringDebounceTimer);
            clusteringDebounceTimer = window.setTimeout(runClusteringAnalysis, 200);
        }

        async function ensureClusteringDataLoaded() {
            initializeClusteringControls();

            if (clusteringSessionsCache) {
                runClusteringAnalysis();
                return;
            }
            if (voteHistorySessionsCache) {
                clusteringSessionsCache = voteHistorySessionsCache;
                runClusteringAnalysis();
                return;
            }
            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                return;
            }
            if (precinctVotesLoadPromise) {
                await precinctVotesLoadPromise;
                if (voteHistorySessionsCache) {
                    clusteringSessionsCache = voteHistorySessionsCache;
                    runClusteringAnalysis();
                    return;
                }
            }
            if (voteHistoryLoadPromise) {
                await voteHistoryLoadPromise;
                if (voteHistorySessionsCache) {
                    clusteringSessionsCache = voteHistorySessionsCache;
                    runClusteringAnalysis();
                    return;
                }
            }

            const total = SESSION_FILES.length;
            let loadedCount = 0;
            setClusteringStatus(`Loading clustering data (0 of ${total})...`);
            setPanelMessage(clusterMemberDetailEl, 'Loading all sessions...');
            setPanelMessage(clusterNeighborsEl, 'Loading all sessions...');
            await ensureVoteGuideLoaded();

            clusteringLoadPromise = Promise.all(
                SESSION_FILES.map(async session => {
                    try {
                        return await fetchAndParseSpreadsheet(session);
                    } catch (err) {
                        throw new Error(`${session.label}: ${err.message}`);
                    } finally {
                        loadedCount += 1;
                        setClusteringStatus(`Loading clustering data (${loadedCount} of ${total})...`);
                    }
                })
            ).then(results => {
                clusteringSessionsCache = results;
                if (!voteHistorySessionsCache) voteHistorySessionsCache = results;
                setClusteringStatus(`Loaded ${total} sessions. Rendering clustering view...`);
                runClusteringAnalysis();
            }).catch(err => {
                console.error(err);
                clearClusterPlot();
                setClusteringStatus(`Error loading clustering data: ${err.message}`, true);
                setPanelMessage(clusterMemberDetailEl, 'Clustering data failed to load.');
                setPanelMessage(clusterNeighborsEl, 'Clustering data failed to load.');
                setPanelMessage(clusterAxisInfoEl, 'Clustering data failed to load.');
            }).finally(() => {
                clusteringLoadPromise = null;
            });

            await clusteringLoadPromise;
        }

        /****************************************************
         * VOTER CLUSTERING — MATRIX BUILDING
         ****************************************************/

        function buildClusteringAnalysis(selectedSessions, minSessions, terminateWeight) {
            if (!selectedSessions || selectedSessions.length === 0) {
                return { error: 'Select at least one session to run clustering.' };
            }

            const allColumns = [];
            const profileMap = new Map();

            selectedSessions.forEach(session => {
                const sessionOrder = getSessionOrderIndex(session.id);
                session.votes.forEach(vote => allColumns.push(vote));

                Object.entries(session.canonicalMembers).forEach(([canonicalKey, memberEntry]) => {
                    if (!profileMap.has(canonicalKey)) {
                        profileMap.set(canonicalKey, {
                            canonicalKey,
                            name: memberEntry.name,
                            precinct: memberEntry.precinct,
                            precincts: new Set(),
                            latestPrecinct: '',
                            latestSessionOrder: -1,
                            sessions: new Set(),
                            rawVotesById: {}
                        });
                    }

                    const profile = profileMap.get(canonicalKey);
                    profile.name = preferDisplayName(profile.name, memberEntry.name);
                    if (memberEntry.precinct) profile.precincts.add(memberEntry.precinct);
                    if (sessionOrder >= profile.latestSessionOrder && memberEntry.precinct) {
                        profile.latestSessionOrder = sessionOrder;
                        profile.latestPrecinct = memberEntry.precinct;
                    }
                    profile.precinct = profile.latestPrecinct || summarizePrecinctSet(profile.precincts);
                    if (memberCastRecordedVote(memberEntry.votesById)) {
                        profile.sessions.add(session.id);
                    }

                    Object.entries(memberEntry.votesById).forEach(([voteId, voteValue]) => {
                        profile.rawVotesById[voteId] = voteValue;
                    });
                });
            });

            const includedProfiles = Array.from(profileMap.values())
                .filter(profile => profile.sessions.size >= minSessions)
                .sort((a, b) => {
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                    return a.name.localeCompare(b.name);
                });

            if (includedProfiles.length === 0) {
                return { error: 'No members match the current minimum sessions setting.' };
            }

            const keptColumns = allColumns.filter(column => {
                let nonMissing = 0;
                includedProfiles.forEach(profile => {
                    const voteValue = profile.rawVotesById[column.id] || 'NoVote';
                    if (voteValue !== 'NoVote') nonMissing += 1;
                });
                return (nonMissing / includedProfiles.length) >= 0.2;
            });

            if (keptColumns.length === 0) {
                return { error: 'No vote columns remain after missing-data filtering.' };
            }

            const membersForPlot = [];
            const matrixRawWithNaN = [];
            const matrixImputed = [];
            const memberIndexByKey = {};

            includedProfiles.forEach((profile, rowIndex) => {
                const rawRow = [];
                const imputedRow = [];
                let votesCast = 0;

                keptColumns.forEach(column => {
                    const voteValue = profile.rawVotesById[column.id] || 'NoVote';
                    if (voteValue === 'NoVote') {
                        rawRow.push(NaN);
                        imputedRow.push(0);
                        return;
                    }

                    let numeric = voteToNumeric(voteValue);
                    if (column.isTerminateDebate) numeric *= terminateWeight;
                    rawRow.push(numeric);
                    imputedRow.push(numeric);
                    votesCast += 1;
                });

                matrixRawWithNaN.push(rawRow);
                matrixImputed.push(imputedRow);

                const memberRecord = {
                    canonicalKey: profile.canonicalKey,
                    name: profile.name,
                    precinct: profile.precinct,
                    sessionsAttended: profile.sessions.size,
                    votesCast,
                    rawVotesById: profile.rawVotesById
                };
                membersForPlot.push(memberRecord);
                memberIndexByKey[profile.canonicalKey] = rowIndex;
            });

            const pcaResult = computePCA2D(matrixImputed);
            if (pcaResult.error) return { error: pcaResult.error };

            membersForPlot.forEach((member, index) => {
                member.x = pcaResult.coordinates[index].x;
                member.y = pcaResult.coordinates[index].y;
            });

            return {
                members: membersForPlot,
                columns: keptColumns,
                matrixRawWithNaN,
                matrixImputed,
                memberIndexByKey,
                selectedSessionsCount: selectedSessions.length,
                varianceExplained: pcaResult.varianceExplained,
                componentVectors: pcaResult.componentVectors,
                axisInterpretation: buildAxisInterpretation(keptColumns, pcaResult.componentVectors)
            };
        }

        /****************************************************
         * VOTER CLUSTERING — PCA
         ****************************************************/

        function dotProduct(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
            return sum;
        }

        function vectorNorm(vector) {
            return Math.sqrt(dotProduct(vector, vector));
        }

        function multiplyMatrixVector(matrix, vector) {
            return matrix.map(row => dotProduct(row, vector));
        }

        function orthogonalizeVector(vector, basis) {
            const projection = dotProduct(vector, basis);
            return vector.map((value, i) => value - (projection * basis[i]));
        }

        function normalizeVector(vector) {
            const norm = vectorNorm(vector);
            if (norm < 1e-12) return null;
            return vector.map(value => value / norm);
        }

        function rayleighQuotient(matrix, vector) {
            const multiplied = multiplyMatrixVector(matrix, vector);
            return dotProduct(vector, multiplied);
        }

        function powerIteration(matrix, maxIterations = 250, tolerance = 1e-9) {
            const n = matrix.length;
            if (n === 0) return null;

            let vector = Array.from({ length: n }, (_, i) => (i === 0 ? 1 : 0));
            const normalizedSeed = normalizeVector(vector);
            if (!normalizedSeed) return null;
            vector = normalizedSeed;

            for (let iter = 0; iter < maxIterations; iter++) {
                const multiplied = multiplyMatrixVector(matrix, vector);
                const normalized = normalizeVector(multiplied);
                if (!normalized) return null;

                const delta = normalized.reduce((sum, value, i) => sum + Math.abs(value - vector[i]), 0);
                vector = normalized;
                if (delta < tolerance) break;
            }

            return {
                vector,
                eigenvalue: rayleighQuotient(matrix, vector)
            };
        }

        function deflateMatrix(matrix, vector, eigenvalue) {
            return matrix.map((row, i) =>
                row.map((value, j) => value - (eigenvalue * vector[i] * vector[j]))
            );
        }

        function buildFallbackUnitVector(length, avoidVector) {
            for (let i = 0; i < length; i++) {
                let candidate = Array.from({ length }, (_, idx) => (idx === i ? 1 : 0));
                if (avoidVector) {
                    candidate = orthogonalizeVector(candidate, avoidVector);
                }
                const normalized = normalizeVector(candidate);
                if (normalized) return normalized;
            }
            return Array.from({ length }, (_, idx) => (idx === 0 ? 1 : 0));
        }

        function buildCovarianceMatrix(centeredMatrix) {
            const rowCount = centeredMatrix.length;
            const colCount = centeredMatrix[0].length;
            const covariance = Array.from({ length: colCount }, () => Array(colCount).fill(0));
            const denom = rowCount > 1 ? rowCount - 1 : 1;

            for (let r = 0; r < rowCount; r++) {
                const row = centeredMatrix[r];
                for (let i = 0; i < colCount; i++) {
                    const xi = row[i];
                    for (let j = i; j < colCount; j++) {
                        covariance[i][j] += xi * row[j];
                    }
                }
            }

            for (let i = 0; i < colCount; i++) {
                for (let j = i; j < colCount; j++) {
                    const value = covariance[i][j] / denom;
                    covariance[i][j] = value;
                    covariance[j][i] = value;
                }
            }
            return covariance;
        }

        function computePCA2D(matrix) {
            const rowCount = matrix.length;
            const colCount = rowCount > 0 ? matrix[0].length : 0;
            if (rowCount === 0 || colCount === 0) {
                return { error: 'Not enough data to run PCA.' };
            }

            const colMeans = Array(colCount).fill(0);
            for (let c = 0; c < colCount; c++) {
                let sum = 0;
                for (let r = 0; r < rowCount; r++) sum += matrix[r][c];
                colMeans[c] = sum / rowCount;
            }

            const centeredMatrix = matrix.map(row =>
                row.map((value, idx) => value - colMeans[idx])
            );
            const covariance = buildCovarianceMatrix(centeredMatrix);

            const totalVariance = covariance.reduce((sum, row, index) => sum + row[index], 0);
            let first = powerIteration(covariance);
            if (!first || !Number.isFinite(first.eigenvalue)) {
                first = {
                    vector: buildFallbackUnitVector(colCount),
                    eigenvalue: 0
                };
            }
            first.eigenvalue = rayleighQuotient(covariance, first.vector);

            const deflated = deflateMatrix(covariance, first.vector, first.eigenvalue);
            let second = powerIteration(deflated);
            if (!second || !Number.isFinite(second.eigenvalue)) {
                second = {
                    vector: buildFallbackUnitVector(colCount, first.vector),
                    eigenvalue: 0
                };
            } else {
                const orthogonalized = orthogonalizeVector(second.vector, first.vector);
                const normalized = normalizeVector(orthogonalized);
                second.vector = normalized || buildFallbackUnitVector(colCount, first.vector);
            }
            second.eigenvalue = rayleighQuotient(covariance, second.vector);

            const rawCoordinates = centeredMatrix.map(row => ({
                x: dotProduct(row, first.vector),
                y: dotProduct(row, second.vector)
            }));

            const maxAbsX = Math.max(...rawCoordinates.map(point => Math.abs(point.x)), 0);
            const maxAbsY = Math.max(...rawCoordinates.map(point => Math.abs(point.y)), 0);
            const scaleX = maxAbsX > 0 ? maxAbsX : 1;
            const scaleY = maxAbsY > 0 ? maxAbsY : 1;
            const coordinates = rawCoordinates.map(point => ({
                x: point.x / scaleX,
                y: point.y / scaleY
            }));

            return {
                coordinates,
                componentVectors: [first.vector, second.vector],
                varianceExplained: {
                    pc1: totalVariance > 0 ? (Math.max(0, first.eigenvalue) / totalVariance) * 100 : 0,
                    pc2: totalVariance > 0 ? (Math.max(0, second.eigenvalue) / totalVariance) * 100 : 0
                }
            };
        }

        function buildAxisInterpretation(columns, componentVectors) {
            return componentVectors.map((vector, idx) => {
                const loadings = columns.map((column, colIndex) => ({
                    column,
                    value: vector[colIndex]
                }));

                return {
                    component: idx + 1,
                    negative: [...loadings].sort((a, b) => a.value - b.value).slice(0, 5),
                    positive: [...loadings].sort((a, b) => b.value - a.value).slice(0, 5)
                };
            });
        }

        /****************************************************
         * VOTER CLUSTERING — RENDERING
         ****************************************************/

        function runClusteringAnalysis() {
            if (!clusteringSessionsCache) return;

            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            const terminateWeightSlider = document.getElementById('cluster-terminate-weight');
            const colorBySelect = document.getElementById('cluster-color-by');
            if (!minSessionsSelect || !terminateWeightSlider || !colorBySelect) return;

            const selectedSessionIds = getSelectedClusteringSessionIds();
            if (selectedSessionIds.size === 0) {
                clearClusterPlot();
                setClusteringStatus('Select at least one session to run clustering.');
                setPanelMessage(clusterMemberDetailEl, 'Select at least one session to run clustering.');
                setPanelMessage(clusterNeighborsEl, 'Select at least one session to run clustering.');
                setPanelMessage(clusterAxisInfoEl, 'Select at least one session to run clustering.');
                selectedClusterMemberKey = null;
                clusteringAnalysisState = null;
                return;
            }

            const selectedSessions = clusteringSessionsCache.filter(session => selectedSessionIds.has(session.id));
            const selectedSessionCount = selectedSessions.length;
            let minSessions = Number.parseInt(minSessionsSelect.value, 10) || 1;
            if (minSessions > selectedSessionCount) {
                minSessions = selectedSessionCount;
                minSessionsSelect.value = String(minSessions);
            }

            const terminateWeight = Number.parseFloat(terminateWeightSlider.value);
            const colorBy = colorBySelect.value;
            const analysis = buildClusteringAnalysis(selectedSessions, minSessions, terminateWeight);

            if (analysis.error) {
                clearClusterPlot();
                setClusteringStatus(analysis.error);
                setPanelMessage(clusterMemberDetailEl, analysis.error);
                setPanelMessage(clusterNeighborsEl, analysis.error);
                setPanelMessage(clusterAxisInfoEl, analysis.error);
                selectedClusterMemberKey = null;
                clusteringAnalysisState = null;
                return;
            }

            clusteringAnalysisState = analysis;
            renderClusteringPlot(analysis, colorBy);
            renderAxisInterpretation(analysis);
            populateClusterMemberSearch(analysis);

            if (selectedClusterMemberKey && analysis.memberIndexByKey[selectedClusterMemberKey] !== undefined) {
                renderClusteringMemberSelection(selectedClusterMemberKey);
            } else {
                selectedClusterMemberKey = null;
                setPanelMessage(clusterMemberDetailEl, 'Click a dot to view this member\'s aggregated voting summary.');
                setPanelMessage(clusterNeighborsEl, 'Click a dot to view the 10 most similar members.');
            }

            setClusteringStatus(
                `Showing ${analysis.members.length} members from ${selectedSessionCount} sessions across ${analysis.columns.length} vote columns.`
            );
        }

        function getClusterMemberSearchLabel(member) {
            return `${member.name} (${formatPrecinctLabel(member.precinct)})`;
        }

        function populateClusterMemberSearch(analysis) {
            const datalist = document.getElementById('cluster-member-options');
            const input = document.getElementById('cluster-member-search');
            if (!datalist || !input) return;

            clusterMemberSearchLabelToKey.clear();
            clusterMemberSearchKeyToLabel.clear();
            datalist.replaceChildren();

            const sortedMembers = [...analysis.members].sort((a, b) => {
                const nameDiff = a.name.localeCompare(b.name);
                if (nameDiff !== 0) return nameDiff;
                return precinctSortValue(a.precinct) - precinctSortValue(b.precinct);
            });

            sortedMembers.forEach(member => {
                const baseLabel = getClusterMemberSearchLabel(member);
                let label = baseLabel;
                if (clusterMemberSearchLabelToKey.has(label)) {
                    label = `${baseLabel} [${member.canonicalKey}]`;
                }

                clusterMemberSearchLabelToKey.set(label, member.canonicalKey);
                clusterMemberSearchKeyToLabel.set(member.canonicalKey, label);

                const option = document.createElement('option');
                option.value = label;
                datalist.appendChild(option);
            });

            if (selectedClusterMemberKey && clusterMemberSearchKeyToLabel.has(selectedClusterMemberKey)) {
                input.value = clusterMemberSearchKeyToLabel.get(selectedClusterMemberKey);
            } else if (!input.value.trim()) {
                input.value = '';
            }
        }

        function selectClusterMemberFromSearch() {
            if (!clusteringAnalysisState) {
                setClusteringStatus('Load clustering data before searching for members.');
                return;
            }

            const input = document.getElementById('cluster-member-search');
            if (!input) return;

            const query = input.value.trim();
            if (!query) {
                setClusteringStatus('Enter a member name to search.');
                return;
            }

            let selectedKey = clusterMemberSearchLabelToKey.get(query) || null;
            let note = '';

            if (!selectedKey) {
                const queryLower = query.toLowerCase();
                const candidates = clusteringAnalysisState.members.filter(member => {
                    const label = getClusterMemberSearchLabel(member).toLowerCase();
                    return (
                        member.name.toLowerCase().includes(queryLower) ||
                        label.includes(queryLower)
                    );
                });

                if (candidates.length === 0) {
                    setClusteringStatus(`No member found for "${query}".`);
                    return;
                }

                candidates.sort((a, b) => {
                    const startsA = a.name.toLowerCase().startsWith(queryLower) ? 0 : 1;
                    const startsB = b.name.toLowerCase().startsWith(queryLower) ? 0 : 1;
                    if (startsA !== startsB) return startsA - startsB;
                    const nameDiff = a.name.localeCompare(b.name);
                    if (nameDiff !== 0) return nameDiff;
                    return precinctSortValue(a.precinct) - precinctSortValue(b.precinct);
                });

                selectedKey = candidates[0].canonicalKey;
                if (candidates.length > 1) {
                    note = ` (${candidates.length} matches, showing closest match)`;
                }
            }

            selectedClusterMemberKey = selectedKey;
            runClusteringAnalysis();
            if (clusterMemberSearchKeyToLabel.has(selectedKey)) {
                input.value = clusterMemberSearchKeyToLabel.get(selectedKey);
            }

            const selectedMember = clusteringAnalysisState.members[clusteringAnalysisState.memberIndexByKey[selectedKey]];
            if (selectedMember) {
                setClusteringStatus(`Selected ${selectedMember.name} (${formatPrecinctLabel(selectedMember.precinct)})${note}.`);
            }
        }

        function formatVoteLabelForPanel(column) {
            return `${column.title} (${column.sessionLabel})`;
        }

        function compareClusterVoteMeta(a, b) {
            const sessionDiff = (SESSION_ORDER_INDEX[a.sessionId] ?? 999) - (SESSION_ORDER_INDEX[b.sessionId] ?? 999);
            if (sessionDiff !== 0) return sessionDiff;

            const aTerminate = a.title.toLowerCase().includes('terminate debate');
            const bTerminate = b.title.toLowerCase().includes('terminate debate');
            if (aTerminate && !bTerminate) return 1;
            if (!aTerminate && bTerminate) return -1;

            const aMatch = a.title.match(/Article (\d+)/i);
            const bMatch = b.title.match(/Article (\d+)/i);
            if (aMatch && bMatch) return parseInt(aMatch[1], 10) - parseInt(bMatch[1], 10);
            return a.title.localeCompare(b.title);
        }

        function renderClusteringMemberSelection(canonicalKey) {
            if (!clusteringAnalysisState) return;

            const analysis = clusteringAnalysisState;
            const rowIndex = analysis.memberIndexByKey[canonicalKey];
            if (rowIndex === undefined) return;

            selectedClusterMemberKey = canonicalKey;
            const member = analysis.members[rowIndex];
            const searchInput = document.getElementById('cluster-member-search');
            if (searchInput && clusterMemberSearchKeyToLabel.has(canonicalKey)) {
                searchInput.value = clusterMemberSearchKeyToLabel.get(canonicalKey);
            }

            if (clusterMemberDetailEl) {
                clusterMemberDetailEl.replaceChildren();

                const meta = document.createElement('div');
                meta.className = 'cluster-member-meta';
                meta.textContent =
                    `${member.name} (${formatPrecinctLabel(member.precinct)}) • ` +
                    `${member.sessionsAttended} sessions attended • ${member.votesCast} recorded votes`;
                clusterMemberDetailEl.appendChild(meta);

                const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };
                analysis.columns.forEach(column => {
                    const voteValue = member.rawVotesById[column.id] || 'NoVote';
                    if (voteValue === 'YES') {
                        voteGroups.YES.push(column);
                    } else if (voteValue === 'NO') {
                        voteGroups.NO.push(column);
                    } else if (voteValue === 'ABSTAIN') {
                        voteGroups.ABSTAIN.push(column);
                    } else {
                        voteGroups.NoVote.push(column);
                    }
                });

                Object.keys(voteGroups).forEach(groupKey => voteGroups[groupKey].sort(compareClusterVoteMeta));

                const total = analysis.columns.length;
                const resultsGrid = document.createElement('div');
                resultsGrid.className = 'results';

                function appendColumn(columnClass, title, items) {
                    const columnEl = document.createElement('div');
                    columnEl.className = `vote-column ${columnClass}`;

                    const percent = total > 0 ? ((items.length / total) * 100).toFixed(1) : '0.0';
                    const header = document.createElement('h3');
                    header.textContent = `${title} (${items.length}, ${percent}%)`;
                    columnEl.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'article-list';

                    items.forEach(columnMeta => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'article-item-with-desc';

                        const titleEl = document.createElement('div');
                        titleEl.className = 'article-title';
                        titleEl.textContent = formatVoteLabelForPanel(columnMeta);
                        wrapper.appendChild(titleEl);

                        if (columnMeta.description) {
                            const desc = document.createElement('div');
                            desc.className = 'article-desc';
                            desc.textContent = columnMeta.description;
                            wrapper.appendChild(desc);
                        }

                        const linksEl = buildArticleLinksElement(columnMeta.links);
                        if (linksEl) {
                            wrapper.appendChild(linksEl);
                        }

                        list.appendChild(wrapper);
                    });

                    columnEl.appendChild(list);
                    resultsGrid.appendChild(columnEl);
                }

                appendColumn('yes', 'Yes', voteGroups.YES);
                appendColumn('no', 'No', voteGroups.NO);
                appendColumn('abstain', 'Abstain', voteGroups.ABSTAIN);
                appendColumn('novote', 'Vote Not Recorded', voteGroups.NoVote);
                clusterMemberDetailEl.appendChild(resultsGrid);
            }

            renderClusteringNeighbors(canonicalKey);
        }

        function computeNearestNeighbors(canonicalKey, analysis, limit = 10) {
            const sourceIndex = analysis.memberIndexByKey[canonicalKey];
            if (sourceIndex === undefined) return [];

            const sourceMember = analysis.members[sourceIndex];
            const sourceRow = analysis.matrixRawWithNaN[sourceIndex];
            const neighbors = [];

            analysis.members.forEach((candidateMember, candidateIndex) => {
                if (candidateIndex === sourceIndex) return;

                const candidateRow = analysis.matrixRawWithNaN[candidateIndex];
                let overlap = 0;
                let agreements = 0;
                let sumSq = 0;

                analysis.columns.forEach((column, colIndex) => {
                    const a = sourceRow[colIndex];
                    const b = candidateRow[colIndex];
                    if (Number.isNaN(a) || Number.isNaN(b)) return;

                    overlap += 1;
                    const diff = a - b;
                    sumSq += diff * diff;

                    const sourceVote = sourceMember.rawVotesById[column.id] || 'NoVote';
                    const candidateVote = candidateMember.rawVotesById[column.id] || 'NoVote';
                    if (sourceVote === candidateVote) agreements += 1;
                });

                if (overlap === 0) {
                    neighbors.push({
                        member: candidateMember,
                        hasOverlap: false,
                        overlap: 0,
                        distance: Number.POSITIVE_INFINITY,
                        agreement: null
                    });
                    return;
                }

                neighbors.push({
                    member: candidateMember,
                    hasOverlap: true,
                    overlap,
                    distance: Math.sqrt(sumSq / overlap),
                    agreement: (agreements / overlap) * 100
                });
            });

            neighbors.sort((a, b) => {
                if (a.hasOverlap !== b.hasOverlap) return a.hasOverlap ? -1 : 1;
                if (a.hasOverlap && b.hasOverlap && a.distance !== b.distance) return a.distance - b.distance;
                return a.member.name.localeCompare(b.member.name);
            });

            return neighbors.slice(0, limit);
        }

        function renderClusteringNeighbors(canonicalKey) {
            if (!clusterNeighborsEl || !clusteringAnalysisState) return;

            const neighbors = computeNearestNeighbors(canonicalKey, clusteringAnalysisState, 10);
            if (neighbors.length === 0) {
                setPanelMessage(clusterNeighborsEl, 'No neighbors available for the selected member.');
                return;
            }

            clusterNeighborsEl.replaceChildren();
            const list = document.createElement('ol');
            list.className = 'cluster-neighbor-list';

            neighbors.forEach((neighbor, index) => {
                const item = document.createElement('li');
                const prefix =
                    `${index + 1}. ${neighbor.member.name} (${formatPrecinctLabel(neighbor.member.precinct)})`;

                if (neighbor.hasOverlap) {
                    item.textContent =
                        `${prefix} - distance ${neighbor.distance.toFixed(3)}, ` +
                        `agreement ${neighbor.agreement.toFixed(1)}% (${neighbor.overlap} shared votes)`;
                } else {
                    item.textContent = `${prefix} - agreement N/A (no overlapping votes)`;
                }

                list.appendChild(item);
            });

            clusterNeighborsEl.appendChild(list);
        }

        function renderAxisInterpretation(analysis) {
            if (!clusterAxisInfoEl) return;

            clusterAxisInfoEl.replaceChildren();

            analysis.axisInterpretation.forEach((componentInfo, index) => {
                const section = document.createElement('div');
                section.className = 'axis-component';

                const header = document.createElement('h4');
                const variance = index === 0 ? analysis.varianceExplained.pc1 : analysis.varianceExplained.pc2;
                header.textContent = `PC${componentInfo.component} (${variance.toFixed(1)}% variance)`;
                section.appendChild(header);

                const negative = document.createElement('div');
                negative.className = 'axis-direction';
                const negativeStrong = document.createElement('strong');
                negativeStrong.textContent = '\u2190 Negative: ';
                negative.appendChild(negativeStrong);
                negative.appendChild(document.createTextNode(
                    componentInfo.negative.map(item => formatVoteLabelForPanel(item.column)).join(', ')
                ));

                const positive = document.createElement('div');
                positive.className = 'axis-direction';
                const positiveStrong = document.createElement('strong');
                positiveStrong.textContent = '\u2192 Positive: ';
                positive.appendChild(positiveStrong);
                positive.appendChild(document.createTextNode(
                    componentInfo.positive.map(item => formatVoteLabelForPanel(item.column)).join(', ')
                ));

                section.appendChild(negative);
                section.appendChild(positive);
                clusterAxisInfoEl.appendChild(section);
            });
        }

        function buildPrecinctColorMap(precincts) {
            const palette = [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
                '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#393b79', '#637939',
                '#8c6d31', '#843c39', '#7b4173', '#3182bd', '#31a354', '#756bb1'
            ];
            const map = {};
            precincts.forEach((precinct, index) => {
                map[precinct] = palette[index % palette.length];
            });
            return map;
        }

        function renderClusteringPlot(analysis, colorBy) {
            if (!clusterPlotEl) return;
            if (typeof Plotly === 'undefined') {
                setClusteringStatus('Plotly is unavailable. Unable to render clustering plot.', true);
                return;
            }

            const hoverTemplate = [
                '<b>%{customdata[1]}</b>',
                'Precinct: %{customdata[2]}',
                'Sessions attended: %{customdata[3]}',
                'Votes cast: %{customdata[4]}',
                '<extra></extra>'
            ].join('<br>');

            const traces = [];

            if (colorBy === 'precinct') {
                const grouped = {};
                analysis.members.forEach(member => {
                    const precinctKey = String(member.precinct).toUpperCase();
                    if (!grouped[precinctKey]) grouped[precinctKey] = [];
                    grouped[precinctKey].push(member);
                });

                const precinctKeys = Object.keys(grouped).sort((a, b) => {
                    const pa = precinctSortValue(a);
                    const pb = precinctSortValue(b);
                    if (pa !== pb) return pa - pb;
                    return a.localeCompare(b);
                });
                const colorMap = buildPrecinctColorMap(precinctKeys);

                precinctKeys.forEach(precinctKey => {
                    const points = grouped[precinctKey];
                    traces.push({
                        type: 'scattergl',
                        mode: 'markers',
                        name: formatPrecinctLabel(precinctKey),
                        x: points.map(member => member.x),
                        y: points.map(member => member.y),
                        customdata: points.map(member => [
                            member.canonicalKey,
                            member.name,
                            member.precinct,
                            member.sessionsAttended,
                            member.votesCast
                        ]),
                        marker: {
                            size: 10,
                            color: colorMap[precinctKey]
                        },
                        hovertemplate: hoverTemplate
                    });
                });
            } else if (colorBy === 'sessions') {
                const maxSessions = Math.max(...analysis.members.map(member => member.sessionsAttended), 1);
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Members',
                    x: analysis.members.map(member => member.x),
                    y: analysis.members.map(member => member.y),
                    customdata: analysis.members.map(member => [
                        member.canonicalKey,
                        member.name,
                        member.precinct,
                        member.sessionsAttended,
                        member.votesCast
                    ]),
                    marker: {
                        size: 10,
                        color: analysis.members.map(member => member.sessionsAttended),
                        colorscale: 'Blues',
                        cmin: 1,
                        cmax: maxSessions,
                        showscale: true,
                        colorbar: { title: 'Sessions' }
                    },
                    hovertemplate: hoverTemplate
                });
            } else {
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Members',
                    x: analysis.members.map(member => member.x),
                    y: analysis.members.map(member => member.y),
                    customdata: analysis.members.map(member => [
                        member.canonicalKey,
                        member.name,
                        member.precinct,
                        member.sessionsAttended,
                        member.votesCast
                    ]),
                    marker: {
                        size: 10,
                        color: '#D02752'
                    },
                    hovertemplate: hoverTemplate
                });
            }

            if (selectedClusterMemberKey && analysis.memberIndexByKey[selectedClusterMemberKey] !== undefined) {
                const selectedMember = analysis.members[analysis.memberIndexByKey[selectedClusterMemberKey]];
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Selected',
                    x: [selectedMember.x],
                    y: [selectedMember.y],
                    customdata: [[
                        selectedMember.canonicalKey,
                        selectedMember.name,
                        selectedMember.precinct,
                        selectedMember.sessionsAttended,
                        selectedMember.votesCast
                    ]],
                    marker: {
                        size: 20,
                        color: 'rgba(0,0,0,0)',
                        line: {
                            color: '#111',
                            width: 3
                        }
                    },
                    showlegend: false,
                    hovertemplate: hoverTemplate
                });
            }

            const layout = {
                margin: { t: 16, r: 20, b: 60, l: 70 },
                height: 600,
                plot_bgcolor: '#ffffff',
                paper_bgcolor: '#ffffff',
                legend: { orientation: 'h', y: -0.15 },
                xaxis: {
                    title: `Component 1 (${analysis.varianceExplained.pc1.toFixed(1)}% variance)`,
                    gridcolor: '#e9ecef',
                    zeroline: true,
                    zerolinecolor: '#ced4da'
                },
                yaxis: {
                    title: `Component 2 (${analysis.varianceExplained.pc2.toFixed(1)}% variance)`,
                    gridcolor: '#e9ecef',
                    zeroline: true,
                    zerolinecolor: '#ced4da'
                }
            };

            Plotly.react(clusterPlotEl, traces, layout, {
                responsive: true,
                displaylogo: false
            });

            if (typeof clusterPlotEl.removeAllListeners === 'function') {
                clusterPlotEl.removeAllListeners('plotly_click');
            }
            if (typeof clusterPlotEl.on === 'function') {
                clusterPlotEl.on('plotly_click', event => {
                    const point = event && event.points && event.points[0];
                    if (!point || !point.customdata) return;
                    selectedClusterMemberKey = point.customdata[0];
                    runClusteringAnalysis();
                });
            }
        }

        /****************************************************
         * TAB SWITCHING
         ****************************************************/

        function getActiveModuleId() {
            const activeTab = document.querySelector('.tab-content.active');
            return activeTab ? activeTab.id : 'by-vote';
        }

        function updateModuleContextControls(activeModuleId = getActiveModuleId()) {
            if (!moduleContextControlsEl) return;
            moduleContextControlsEl.style.display = SINGLE_SESSION_MODULE_IDS.has(activeModuleId) ? 'block' : 'none';
        }

        function updateModuleInstruction(activeModuleId = getActiveModuleId()) {
            if (!moduleInstructionEl) return;

            if (activeModuleId === 'member-networks') {
                moduleInstructionEl.textContent = 'Member Networks uses all Town Meeting sessions attended by the selected member.';
                moduleInstructionEl.style.display = 'block';
                return;
            }

            if (activeModuleId === 'vote-history') {
                moduleInstructionEl.textContent = 'Click on a Town Meeting session to see the details about the votes in that session.';
                moduleInstructionEl.style.display = 'block';
                return;
            }
            
            if (activeModuleId === 'precinct-votes') {
                moduleInstructionEl.textContent = 'Click on a Town Meeting session to see how each precinct voted in that session.';
                moduleInstructionEl.style.display = 'block';
                return;
            }
            moduleInstructionEl.textContent = '';
            moduleInstructionEl.style.display = 'none';
        }

        function setActiveTabButton(evt, tabName) {
            const tabs = Array.from(document.querySelectorAll('.tab'));
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            if (evt && evt.target && evt.target.classList && evt.target.classList.contains('tab')) {
                evt.target.classList.add('active');
                return;
            }

            const tabButton = tabs.find(tab => tab.dataset.tab === tabName);
            if (tabButton) tabButton.classList.add('active');
        }

        function switchTab(evt, tabName) {
            setActiveTabButton(evt, tabName);

            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const targetTab = document.getElementById(tabName);
            if (targetTab) targetTab.classList.add('active');
            updateModuleContextControls(tabName);
            updateModuleInstruction(tabName);

            // Lazy-load cross-session modules only when activated.
            if (tabName === 'by-member' && members.length > 0) {
                updateMemberResults();
            }

            if (tabName === 'member-networks') {
                ensureMemberNetworkDataLoaded();
            }

            if (tabName === 'vote-history') {
                ensureVoteHistoryDataLoaded();
            }

            if (tabName === 'precinct-votes') {
                ensurePrecinctVotesDataLoaded();
            }

            if (tabName === 'contentious-votes') {
                ensureContentiousVotesDataLoaded();
            }

            if (tabName === 'voter-clustering') {
                ensureClusteringDataLoaded();
            }
        }

        function enterVoteAnalyzerMode() {
            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';

            const titleEl = document.querySelector('.container h1');
            if (titleEl) titleEl.textContent = 'Brookline Vote Analyzer';

            const subtitleEl = document.querySelector('.subtitle');
            if (subtitleEl) {
                subtitleEl.textContent = 'Advanced clustering and cross-session voting pattern analysis.';
            }

            updateModuleContextControls('voter-clustering');
            updateModuleInstruction('voter-clustering');

            const tabsBar = document.getElementById('module-menu');
            if (tabsBar) tabsBar.style.display = 'none';

            const byVoteEl = document.getElementById('by-vote');
            const byMemberEl = document.getElementById('by-member');
            const memberNetworksEl = document.getElementById('member-networks');
            const voteHistoryEl = document.getElementById('vote-history');
            const precinctVotesEl = document.getElementById('precinct-votes');
            const contentiousVotesEl = document.getElementById('contentious-votes');
            const clusteringEl = document.getElementById('voter-clustering');
            if (byVoteEl) byVoteEl.classList.remove('active');
            if (byMemberEl) byMemberEl.classList.remove('active');
            if (memberNetworksEl) memberNetworksEl.classList.remove('active');
            if (voteHistoryEl) voteHistoryEl.classList.remove('active');
            if (precinctVotesEl) precinctVotesEl.classList.remove('active');
            if (contentiousVotesEl) contentiousVotesEl.classList.remove('active');
            if (clusteringEl) clusteringEl.classList.add('active');

            ensureClusteringDataLoaded();
        }

        /****************************************************
         * INITIAL PAGE LOAD
         ****************************************************/

        window.addEventListener('DOMContentLoaded', () => {
            if (APP_MODE === 'vote-analyzer') {
                enterVoteAnalyzerMode();
                return;
            }

            // Bind once at startup; subsequent data loads only repopulate controls.
            const voteSelect = document.getElementById('vote-select');
            if (voteSelect) voteSelect.addEventListener('change', updateVoteResults);

            const memberSelect = document.getElementById('member-select');
            if (memberSelect) memberSelect.addEventListener('change', updateMemberResults);

            const spreadsheetSelect = document.getElementById('spreadsheet-select');
            if (spreadsheetSelect) {
                spreadsheetSelect.addEventListener('change', () => {
                    if (loadingEl) {
                        loadingEl.style.display = 'block';
                        loadingEl.textContent = 'Loading voting data...';
                    }
                    if (mainContentEl) mainContentEl.style.display = 'none';

                    // Required full reset before loading a different meeting spreadsheet.
                    votingData = null;
                    votes = [];
                    members = [];

                    loadVotingDataFromExcel();
                });
            }

            updateModuleContextControls('by-vote');
            updateModuleInstruction('by-vote');
            loadVotingDataFromExcel();
        });
    </script>

</body>

</html>
