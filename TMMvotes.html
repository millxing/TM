<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Make layout responsive on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brookline Town Meeting Voting Analysis</title>

    <!-- XLSX library for reading Excel files directly in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Plotly for interactive scatter plots in voter clustering -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        /* Basic reset to make sizing and spacing predictable */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Overall page styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            color: #333;
        }

        /* Main centered card container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        /* Main title */
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 28px;
        }

        /* Subtitle text under title */
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 16px;
        }

        /* Tab bar container */
        .tabs {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 30px;
        }

        /* Individual tab button */
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .tab:hover {
            color: #333;
        }

        /* Active tab styling */
        .tab.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
            font-weight: 600;
        }

        /* Base hidden state for tab content */
        .tab-content {
            display: none;
        }

        /* Shown tab content */
        .tab-content.active {
            display: block;
        }

        /* Container for the “controls” row above the results */
        .controls {
            margin-bottom: 25px;
        }

        /* Layout for label + selects + checkboxes */
        .control-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        /* Styling for all <select> dropdowns */
        select {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
            min-width: 300px;
        }

        select:hover {
            border-color: #3498db;
        }

        select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        /* Checkbox + label container */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Grid layout used in “view by vote” (four columns of results) */
        .results {
            display: grid;
            grid-template-columns: repeat(4, minmax(300px, 1fr));
            gap: 20px;
        }

        /* Wrapper for the entire vote result area */
        .vote-results-container {
            width: 100%;
        }

        /* Base styling for each vote column (Yes/No/Abstain/No Vote) */
        .vote-column {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .vote-column h3 {
            font-size: 18px;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
        }

        /* Article description box shown above vote results when in View by Vote */
        .article-description {
            background-color: #e8f4f8;
            border: 1px solid #b8e0e8;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.4;
        }

        .article-description h4 {
            margin-bottom: 6px;
            color: #2c3e50;
            font-size: 14px;
            font-weight: 600;
        }

        .article-meta {
            margin-bottom: 8px;
            color: #4a5b6b;
            font-size: 13px;
            font-weight: 600;
        }

        .article-summary-line {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            color: #4a5b6b;
            font-size: 13px;
            font-weight: 600;
        }

        .article-summary-primary {
            color: #2c3e50;
            font-size: 14px;
        }

        .article-summary-separator {
            color: #8a99a5;
        }

        /* Wrapper used in View by Member for title+description pairs */
        .article-item-with-desc {
            margin-bottom: 12px;
        }

        .article-title {
            padding: 8px 12px;
            background-color: white;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid #e9ecef;
            font-weight: 600;
            color: #2c3e50;
        }

        .article-desc {
            padding: 6px 12px;
            margin-top: 4px;
            margin-left: 12px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            color: #666;
            font-style: italic;
            border-left: 3px solid #dee2e6;
        }

        .article-detail {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background-color: white;
        }

        .article-title-toggle {
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .article-title-toggle::-webkit-details-marker {
            display: none;
        }

        .article-title-toggle::after {
            content: '+';
            color: #1f78b4;
            font-size: 16px;
            font-weight: 700;
            line-height: 1;
            margin-left: 12px;
        }

        .article-detail[open] .article-title-toggle::after {
            content: '-';
        }

        .article-detail-body {
            padding-bottom: 8px;
        }

        .article-vote-result {
            margin-left: 12px;
            margin-top: 4px;
            margin-bottom: 6px;
            color: #4a5b6b;
            font-size: 13px;
            font-weight: 600;
        }

        .article-links {
            margin-top: 6px;
            margin-left: 12px;
            padding-left: 0;
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .article-links li {
            margin-bottom: 0;
            font-size: 13px;
            line-height: 1.35;
            display: inline-flex;
            align-items: center;
        }

        .article-links li:not(:last-child)::after {
            content: '•';
            margin-left: 8px;
            color: #8a99a5;
        }

        .article-links a {
            color: #1f78b4;
            text-decoration: underline;
        }

        /* Color theming for the four vote types */
        .vote-column.yes h3 {
            background-color: #d4edda;
            color: #155724;
        }

        .vote-column.no h3 {
            background-color: #f8d7da;
            color: #721c24;
        }

        .vote-column.abstain h3 {
            background-color: #fff3cd;
            color: #856404;
        }

        .vote-column.novote h3 {
            background-color: #e2e3e5;
            color: #383d41;
        }

        /* Scrollable list of members or articles */
        .member-list,
        .article-list {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 5px;
        }

        /* Individual line items for members/articles */
        .member-item,
        .article-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            background-color: white;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
        }

        .member-item:hover,
        .article-item:hover {
            background-color: #f1f3f5;
            transform: translateX(2px);
        }

        /* Styling for the precinct label prefix inside member rows */
        .precinct-label {
            font-weight: 600;
            color: #666;
        }

        /* Centered loading / error text */
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .cluster-status {
            margin-bottom: 16px;
            padding: 12px 16px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            color: #555;
        }

        .cluster-status.error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .cluster-controls {
            align-items: flex-start;
        }

        .cluster-control-block {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 360px;
        }

        .cluster-control-inline {
            display: flex;
            gap: 14px;
            align-items: center;
            flex-wrap: wrap;
        }

        .cluster-inline-select {
            min-width: 170px;
        }

        .cluster-member-search-group {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
            flex-wrap: nowrap;
        }

        .cluster-member-search-group label {
            white-space: nowrap;
        }

        .cluster-member-search-group .cluster-search-input {
            flex: 1 1 auto;
            min-width: 220px;
        }

        .cluster-search-input {
            min-width: 260px;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            background-color: white;
            transition: border-color 0.3s ease;
        }

        .cluster-search-input:hover {
            border-color: #3498db;
        }

        .cluster-search-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .cluster-action-btn {
            padding: 10px 14px;
            border: 2px solid #3498db;
            border-radius: 8px;
            background-color: #3498db;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cluster-action-btn:hover {
            background-color: #2d87c6;
            border-color: #2d87c6;
        }

        .session-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .session-option {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background-color: #f8f9fa;
            font-size: 13px;
            color: #2c3e50;
        }

        .session-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .cluster-slider-group {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 8px 12px;
        }

        .cluster-slider-group input[type="range"] {
            width: 180px;
            accent-color: #3498db;
        }

        .cluster-slider-value {
            min-width: 36px;
            font-weight: 600;
            color: #2c3e50;
            text-align: right;
        }

        .cluster-plot {
            width: 100%;
            height: 600px;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            background-color: #fff;
        }

        .cluster-panels {
            display: grid;
            grid-template-columns: repeat(2, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .cluster-panel {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 16px;
        }

        .cluster-panel.member-detail {
            grid-column: 1 / -1;
        }

        .cluster-panel h3 {
            margin-bottom: 12px;
            color: #2c3e50;
            font-size: 17px;
        }

        .cluster-panel-body {
            font-size: 14px;
            color: #444;
        }

        .cluster-message {
            color: #666;
            font-style: italic;
        }

        .cluster-member-meta {
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .cluster-neighbor-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .cluster-neighbor-list li {
            padding: 8px 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background-color: #fff;
            margin-bottom: 6px;
            line-height: 1.4;
        }

        .axis-component {
            margin-bottom: 16px;
            background-color: #fff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 10px 12px;
        }

        .axis-component h4 {
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 14px;
        }

        .axis-direction {
            margin-bottom: 8px;
            font-size: 13px;
            line-height: 1.4;
        }

        .axis-direction strong {
            color: #2c3e50;
        }

        .page-footer {
            margin-top: 28px;
            padding-top: 18px;
            border-top: 1px solid #e3e8ed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .page-footer-text {
            text-align: center;
            color: #445566;
            font-size: 16px;
            line-height: 1.45;
        }

        .page-footer-text a {
            color: inherit;
            text-decoration: underline;
        }

        .page-footer-credit {
            font-weight: 700;
        }

        .page-footer-logo {
            width: 120px;
            height: auto;
            display: block;
            flex: 0 0 auto;
        }

        @media (max-width: 900px) {
            select {
                min-width: 220px;
            }

            .cluster-control-block {
                min-width: 280px;
            }

            .cluster-panels {
                grid-template-columns: 1fr;
            }

            .page-footer-logo {
                width: 80px;
            }

            .results {
                grid-template-columns: repeat(2, minmax(260px, 1fr));
            }
        }

        @media (max-width: 640px) {
            select {
                min-width: 180px;
            }

            .cluster-member-search-group {
                width: 100%;
            }

            .cluster-member-search-group .cluster-search-input {
                min-width: 0;
            }

            .results {
                grid-template-columns: 1fr;
            }

            .cluster-plot {
                height: 480px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Brookline Town Meeting Voting Analysis</h1>
        <p class="subtitle">Use the dropdown below to select a Town Meeting session.</p>

        <!-- Shown initially while spreadsheet data is being fetched and parsed -->
        <div class="loading" id="loading">
            Loading voting data...
        </div>

        <!-- All main content is hidden until data is successfully loaded -->
        <div id="main-content" style="display: none;">

            <!-- Spreadsheet selector -->
            <div class="controls" style="margin-bottom: 20px;">
                <div class="control-group">
                    <label for="spreadsheet-select">Select Town Meeting:</label>
                    <!--
                        value is URL-encoded file name located in:
                        https://github.com/millxing/TM/blob/main/<file>
                        which is fetched via the GitHub raw URL.
                    -->
                    <select id="spreadsheet-select">
                        <option value="Votes/November%202025%20Votes.xlsx" selected>November 2025 Votes (19 votes)</option>
                        <option value="Votes/May%202025%20Votes.xlsx">May 2025 Votes (45 votes)</option>
                        <option value="Votes/November%202024%20Votes.xlsx">November 2024 Votes (28 votes)</option>
                        <option value="Votes/May%202024%20Votes.xlsx">May 2024 Votes (34 votes)</option>
                        <option value="Votes/November%202023%20Votes.xlsx">November 2023 Votes (24 votes)</option>
                        <option value="Votes/May%202023%20Votes.xlsx">May 2023 Votes (44 votes)</option>
                        <option value="Votes/January%202023%20Votes.xlsx">January 2023 Votes (4 votes)</option>
                        <option value="Votes/November%202022%20Votes.xlsx">November 2022 Votes (68 votes)</option>
                        <option value="Votes/May%202022%20Votes.xlsx">May 2022 Votes (57 votes)</option>
                        <option value="Votes/November%202021%20Votes.xlsx">November 2021 Votes (48 votes)</option>
                        <option value="Votes/October%202021%20Votes.xlsx">October 2021 Votes (10 votes)</option>
                        <option value="Votes/May%202021%20Votes.xlsx">May 2021 Votes (68 votes)</option>
                    </select>
                </div>
            </div>

            <!-- Tab selector buttons: View by Vote vs View by Member -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab(event, 'by-vote')">View by Vote</button>
                <button class="tab" onclick="switchTab(event, 'by-member')">View by Member</button>
            </div>

            <!-- TAB: View by Vote -->
            <div id="by-vote" class="tab-content active">
                <div class="controls">
                    <div class="control-group">
                        <label for="vote-select">Select Vote:</label>
                        <!-- Populated dynamically with article titles from the spreadsheet -->
                        <select id="vote-select"></select>
                        <div class="checkbox-group">
                            <!-- When checked, sorts by last name only instead of precinct+name -->
                            <input type="checkbox" id="sort-by-name-vote" onchange="updateVoteResults()">
                            <label for="sort-by-name-vote">Sort by last name only</label>
                        </div>
                    </div>
                </div>
                <!-- Container where the four vote-columns (Yes/No/Abstain/No Vote) are rendered -->
                <div id="vote-results" class="vote-results-container"></div>
            </div>

            <!-- TAB: View by Member -->
            <div id="by-member" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label for="member-select">Select Member:</label>
                        <!-- Populated dynamically with "Name (Precinct X)" options -->
                        <select id="member-select"></select>
                        <div class="checkbox-group">
                            <!-- When checked, sort member dropdown by precinct then name -->
                            <input type="checkbox" id="sort-by-precinct-member" onchange="populateMemberDropdown()">
                            <label for="sort-by-precinct-member">Sort by precinct, then name</label>
                        </div>
                    </div>
                </div>
                <!-- Grid of four columns: for this one member, show which articles they voted Yes/No/Abstain/No Vote -->
                <div id="member-results" class="results"></div>
            </div>

            <!-- TAB: Voter Clustering -->
            <div id="voter-clustering" class="tab-content">
                <div class="controls">
                    <div class="control-group cluster-controls">
                        <div class="cluster-control-block">
                            <label>Sessions to include:</label>
                            <div id="cluster-session-checkboxes" class="session-checkboxes"></div>
                        </div>
                        <div class="cluster-control-inline">
                            <label for="cluster-min-sessions">Minimum sessions:</label>
                            <select id="cluster-min-sessions" class="cluster-inline-select"></select>

                            <div class="cluster-slider-group">
                                <label for="cluster-terminate-weight">Terminate Debate weight:</label>
                                <input type="range" id="cluster-terminate-weight" min="0" max="1" step="0.1" value="0">
                                <span id="cluster-terminate-weight-value" class="cluster-slider-value">0.0</span>
                            </div>

                            <label for="cluster-color-by">Color by:</label>
                            <select id="cluster-color-by" class="cluster-inline-select">
                                <option value="precinct">Precinct</option>
                                <option value="sessions">Number of sessions attended</option>
                                <option value="none" selected>None</option>
                            </select>

                            <div class="cluster-member-search-group">
                                <label for="cluster-member-search">Find member:</label>
                                <input
                                    type="search"
                                    id="cluster-member-search"
                                    class="cluster-search-input"
                                    list="cluster-member-options"
                                    placeholder="Type member name..."
                                    autocomplete="off">
                                <button type="button" id="cluster-member-search-go" class="cluster-action-btn">Select</button>
                            </div>
                            <datalist id="cluster-member-options"></datalist>
                        </div>
                    </div>
                </div>

                <div id="cluster-status" class="cluster-status">Open this tab to load all sessions.</div>
                <div id="cluster-plot" class="cluster-plot"></div>

                <div class="cluster-panels">
                    <div class="cluster-panel member-detail">
                        <h3>Selected Member</h3>
                        <div id="cluster-member-detail" class="cluster-panel-body">
                            <div class="cluster-message">Click a dot to view this member's aggregated voting summary.</div>
                        </div>
                    </div>
                    <div class="cluster-panel">
                        <h3>Nearest Neighbors</h3>
                        <div id="cluster-neighbors" class="cluster-panel-body">
                            <div class="cluster-message">Click a dot to view the 10 most similar members.</div>
                        </div>
                    </div>
                    <div class="cluster-panel">
                        <h3>Axis Interpretation</h3>
                        <div id="cluster-axis-info" class="cluster-panel-body">
                            <div class="cluster-message">Run clustering to inspect top positive and negative loadings for PC1 and PC2.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="page-footer">
            <div class="page-footer-text">
                <p>If you find any bugs or errors, please report them to: robschoen.robschoen at gmail dot com</p>
                <p class="page-footer-credit">created by Rob Schoen TMM P1 // Entangled Particles // <a href="https://www.longwoodmall.org" target="_blank" rel="noopener noreferrer">www.longwoodmall.org</a></p>
            </div>
            <img class="page-footer-logo" src="entangledParticlesLogo.jpg" alt="Entangled Particles logo">
        </footer>
    </div>


    <script>
        /****************************************************
         * SPREADSHEET STRUCTURE CONFIGURATION
         ****************************************************/

        const TITLE_ROW_INDEX = 2;
        const DESCRIPTION_ROW_INDEX = 3;
        const HEADER_ROW_INDEX = 4;
        const FIRST_DATA_ROW_INDEX = 5;

        const PRECINCT_COL_INDEX = 0;
        const NAME_COL_INDEX = 1;
        const FIRST_VOTE_COL_INDEX = 2;
        const VOTE_GUIDE_FILE_NAMES = [
            'VoteGuide.xlsx',
            'Vote%20Guide.xlsx',
            'voteguide.xlsx'
        ];

        const SPREADSHEET_BASE_URL = 'https://raw.githubusercontent.com/millxing/TM/main/';
        const DISALLOWED_MEMBER_NAMES = new Set(['YES', 'NO', 'ABSTAIN', 'NO VOTE', 'TOTAL', 'ARTICLE', 'MOTION']);
        const SESSION_FILES = [
            { id: '2021-05', label: 'May 2021', file: 'Votes/May%202021%20Votes.xlsx' },
            { id: '2021-10', label: 'October 2021', file: 'Votes/October%202021%20Votes.xlsx' },
            { id: '2021-11', label: 'November 2021', file: 'Votes/November%202021%20Votes.xlsx' },
            { id: '2022-05', label: 'May 2022', file: 'Votes/May%202022%20Votes.xlsx' },
            { id: '2022-11', label: 'November 2022', file: 'Votes/November%202022%20Votes.xlsx' },
            { id: '2023-01', label: 'January 2023', file: 'Votes/January%202023%20Votes.xlsx' },
            { id: '2023-05', label: 'May 2023', file: 'Votes/May%202023%20Votes.xlsx' },
            { id: '2023-11', label: 'November 2023', file: 'Votes/November%202023%20Votes.xlsx' },
            { id: '2024-05', label: 'May 2024', file: 'Votes/May%202024%20Votes.xlsx' },
            { id: '2024-11', label: 'November 2024', file: 'Votes/November%202024%20Votes.xlsx' },
            { id: '2025-05', label: 'May 2025', file: 'Votes/May%202025%20Votes.xlsx' },
            { id: '2025-11', label: 'November 2025', file: 'Votes/November%202025%20Votes.xlsx' }
        ];
        const SESSION_ORDER_INDEX = SESSION_FILES.reduce((acc, session, index) => {
            acc[session.id] = index;
            return acc;
        }, {});

        /****************************************************
         * GLOBAL STATE
         ****************************************************/

        let LAST_VOTE_COL_INDEX = 100;
        let votingData = null;
        let votes = [];
        let members = [];
        let voteGuideLoadPromise = null;
        let voteGuideLoadComplete = false;
        let voteGuideBySessionAndVote = new Map();
        let voteGuideBySessionAndLooseVote = new Map();

        let clusteringSessionsCache = null;
        let clusteringLoadPromise = null;
        let clusteringControlsInitialized = false;
        let clusteringDebounceTimer = null;
        let clusteringAnalysisState = null;
        let selectedClusterMemberKey = null;
        const clusterMemberSearchLabelToKey = new Map();
        const clusterMemberSearchKeyToLabel = new Map();
        const APP_MODE = new URLSearchParams(window.location.search).get('app') === 'vote-analyzer'
            ? 'vote-analyzer'
            : 'tmmvotes';

        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        const clusterStatusEl = document.getElementById('cluster-status');
        const clusterPlotEl = document.getElementById('cluster-plot');
        const clusterMemberDetailEl = document.getElementById('cluster-member-detail');
        const clusterNeighborsEl = document.getElementById('cluster-neighbors');
        const clusterAxisInfoEl = document.getElementById('cluster-axis-info');

        /****************************************************
         * URL / FILE HELPERS
         ****************************************************/

        function getSpreadsheetRawURL(file) {
            return `${SPREADSHEET_BASE_URL}${file}`;
        }

        function getSelectedSpreadsheetURL() {
            const select = document.getElementById('spreadsheet-select');
            const file = select ? select.value : 'Votes/November%202025%20Votes.xlsx';
            return getSpreadsheetRawURL(file);
        }

        function getCurrentSpreadsheetMeta() {
            const select = document.getElementById('spreadsheet-select');
            const selectedIndex = select ? select.selectedIndex : -1;
            const option = select && selectedIndex >= 0 ? select.options[selectedIndex] : null;
            const file = option ? option.value : 'Votes/November%202025%20Votes.xlsx';
            const labelText = option ? option.textContent : 'Selected Session';
            const label = labelText ? labelText.split('(')[0].trim() : 'Selected Session';
            const knownSession = SESSION_FILES.find(session => session.file === file);

            return {
                id: knownSession ? knownSession.id : 'single-session',
                label: knownSession ? knownSession.label : label,
                file
            };
        }

        function buildVoteGuideCandidateFiles() {
            const selectedMeta = getCurrentSpreadsheetMeta();
            const selectedFile = String(selectedMeta.file || '');
            const selectedDir = selectedFile.includes('/')
                ? selectedFile.slice(0, selectedFile.lastIndexOf('/') + 1)
                : '';

            const candidateSet = new Set();

            VOTE_GUIDE_FILE_NAMES.forEach(name => {
                if (selectedDir) candidateSet.add(`${selectedDir}${name}`);
                candidateSet.add(`Votes/${name}`);
                candidateSet.add(`Vote/${name}`);
                candidateSet.add(name);
            });

            return Array.from(candidateSet);
        }

        /****************************************************
         * DATA NORMALIZATION & SORT HELPERS
         ****************************************************/

        function precinctSortValue(precinct) {
            const n = parseInt(precinct, 10);
            if (!isNaN(n)) return n;
            if (String(precinct).toUpperCase() === 'AL') return 999;
            return 998;
        }

        function normalizeVote(raw) {
            const value = (raw == null ? '' : String(raw)).trim().toUpperCase();
            if (!value) return 'NoVote';
            if (value === 'Y') return 'YES';
            if (value === 'N') return 'NO';
            if (value === 'A') return 'ABSTAIN';
            if (value === 'YES' || value === 'NO' || value === 'ABSTAIN') return value;
            return 'NoVote';
        }

        function voteToNumeric(voteValue) {
            if (voteValue === 'YES') return 1;
            if (voteValue === 'NO') return -1;
            if (voteValue === 'ABSTAIN') return 0;
            return NaN;
        }

        function normalizeMemberName(name) {
            return String(name || '').trim().toLowerCase().replace(/\s+/g, ' ');
        }

        function canonicalMemberKey(name, precinct) {
            return `${normalizeMemberName(name)}|${String(precinct || '').trim().toUpperCase()}`;
        }

        function formatPrecinctLabel(precinct) {
            const up = String(precinct).toUpperCase();
            if (up === 'AL') return 'AL';
            return `P${precinct}`;
        }

        function isTerminateDebateVote(title) {
            return String(title || '').toLowerCase().includes('terminate debate');
        }

        function normalizeVoteResult(value) {
            const text = String(value || '').trim().toUpperCase();
            if (!text) return '';
            if (text.includes('APPROVED')) return 'APPROVED';
            if (text.includes('FAILED')) return 'FAILED';
            return '';
        }

        function extractVoteResultsByColumn(rows, startRowIndex, lastVoteColIndex) {
            if (!Array.isArray(rows) || rows.length === 0) return {};

            let bestRowIndex = -1;
            let bestMatchCount = 0;
            const scanStart = Math.max(0, startRowIndex);

            for (let r = scanStart; r < rows.length; r++) {
                const row = rows[r] || [];
                let matchCount = 0;
                for (let col = FIRST_VOTE_COL_INDEX; col <= lastVoteColIndex; col++) {
                    if (normalizeVoteResult(row[col])) matchCount += 1;
                }

                if (matchCount > bestMatchCount) {
                    bestMatchCount = matchCount;
                    bestRowIndex = r;
                }
            }

            if (bestRowIndex < 0 || bestMatchCount === 0) return {};

            const resultsByCol = {};
            const resultRow = rows[bestRowIndex] || [];
            for (let col = FIRST_VOTE_COL_INDEX; col <= lastVoteColIndex; col++) {
                const voteResult = normalizeVoteResult(resultRow[col]);
                if (voteResult) resultsByCol[col] = voteResult;
            }
            return resultsByCol;
        }

        function normalizeVoteTitleForMatch(title) {
            return String(title || '')
                .toLowerCase()
                .replace(/\s+/g, ' ')
                .trim();
        }

        function buildVoteGuideKey(sessionId, voteTitle) {
            return `${sessionId}||${normalizeVoteTitleForMatch(voteTitle)}`;
        }

        function normalizeVoteTitleForLooseMatch(title) {
            return normalizeVoteTitleForMatch(title)
                .replace(/\barticles\b/g, 'article')
                .replace(/\bmain motion\b/g, 'motion')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function buildLooseVoteGuideKey(sessionId, voteTitle) {
            return `${sessionId}||${normalizeVoteTitleForLooseMatch(voteTitle)}`;
        }

        function getSessionIdFromGuideLabel(sessionLabel) {
            const normalized = String(sessionLabel || '').toLowerCase().trim();
            if (!normalized) return null;

            const direct = SESSION_FILES.find(session =>
                normalized.includes(session.label.toLowerCase())
            );
            if (direct) return direct.id;

            const match = normalized.match(/\b(january|may|october|november)\s+(20\d{2})\b/i);
            if (!match) return null;

            const monthMap = { january: '01', may: '05', october: '10', november: '11' };
            const month = monthMap[match[1].toLowerCase()];
            const year = match[2];
            const candidate = `${year}-${month}`;
            return SESSION_ORDER_INDEX[candidate] !== undefined ? candidate : null;
        }

        function getVoteGuideDetails(sessionId, voteTitle) {
            if (!sessionId || voteGuideBySessionAndVote.size === 0) return null;
            return (
                voteGuideBySessionAndVote.get(buildVoteGuideKey(sessionId, voteTitle)) ||
                voteGuideBySessionAndLooseVote.get(buildLooseVoteGuideKey(sessionId, voteTitle)) ||
                null
            );
        }

        function buildArticleLinksElement(links) {
            if (!Array.isArray(links) || links.length === 0) return null;

            const sanitizedLinks = links
                .map(link => String(link || '').trim())
                .filter(link => /^https?:\/\//i.test(link));
            if (sanitizedLinks.length === 0) return null;

            const listEl = document.createElement('ul');
            listEl.className = 'article-links';

            sanitizedLinks.forEach((url, index) => {
                const itemEl = document.createElement('li');
                const linkEl = document.createElement('a');
                linkEl.href = url;
                linkEl.target = '_blank';
                linkEl.rel = 'noopener noreferrer';
                linkEl.textContent = `Reference ${index + 1}`;
                itemEl.appendChild(linkEl);
                listEl.appendChild(itemEl);
            });

            return listEl;
        }

        /****************************************************
         * LOADING & PARSING EXCEL
         ****************************************************/

        function parseVoteGuideRows(rows) {
            const index = new Map();
            const looseIndex = new Map();
            if (!rows || rows.length < 2) return { index, looseIndex };

            const headers = (rows[0] || []).map(cell => String(cell || '').trim().toLowerCase());
            const sessionCol = headers.findIndex(header => header === 'town meeting session');
            const nightCol = headers.findIndex(header => header.startsWith('night'));
            const voteCol = headers.findIndex(header => header === 'vote');
            const descriptionCol = headers.findIndex(header => header === 'description');
            const linkCols = headers
                .map((header, idx) => ({ header, idx }))
                .filter(entry => entry.header.startsWith('link'))
                .map(entry => entry.idx);

            if (sessionCol < 0 || voteCol < 0) return { index, looseIndex };

            for (let r = 1; r < rows.length; r++) {
                const row = rows[r] || [];
                const sessionLabel = String(row[sessionCol] || '').trim();
                const voteTitle = String(row[voteCol] || '').trim();
                if (!sessionLabel || !voteTitle) continue;

                const sessionId = getSessionIdFromGuideLabel(sessionLabel);
                if (!sessionId) continue;

                const description = descriptionCol >= 0 ? String(row[descriptionCol] || '').trim() : '';
                const night = nightCol >= 0 ? String(row[nightCol] || '').trim() : '';
                const links = linkCols
                    .map(colIndex => String(row[colIndex] || '').trim())
                    .filter(link => /^https?:\/\//i.test(link));

                const key = buildVoteGuideKey(sessionId, voteTitle);
                const mergeGuideEntry = (existing, incoming) => {
                    if (!existing) return incoming;
                    const mergedLinks = Array.from(new Set([...(existing.links || []), ...(incoming.links || [])]));
                    return {
                        description: (incoming.description.length > (existing.description || '').length)
                            ? incoming.description
                            : existing.description,
                        night: existing.night || incoming.night,
                        links: mergedLinks,
                        sessionLabel: existing.sessionLabel || incoming.sessionLabel
                    };
                };

                const incoming = { description, night, links, sessionLabel };
                index.set(key, mergeGuideEntry(index.get(key), incoming));

                const looseKey = buildLooseVoteGuideKey(sessionId, voteTitle);
                looseIndex.set(looseKey, mergeGuideEntry(looseIndex.get(looseKey), incoming));
            }

            return { index, looseIndex };
        }

        async function ensureVoteGuideLoaded() {
            if (voteGuideLoadComplete || voteGuideBySessionAndVote.size > 0) return;
            if (voteGuideLoadPromise) {
                await voteGuideLoadPromise;
                return;
            }

            voteGuideLoadPromise = (async () => {
                try {
                    let loadedFromFile = '';
                    const attemptErrors = [];
                    const candidateFiles = buildVoteGuideCandidateFiles();

                    for (const guideFile of candidateFiles) {
                        try {
                            const response = await fetch(getSpreadsheetRawURL(guideFile));
                            if (!response.ok) {
                                attemptErrors.push(`${guideFile}: HTTP ${response.status} ${response.statusText}`);
                                continue;
                            }

                            const arrayBuffer = await response.arrayBuffer();
                            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const sheet = workbook.Sheets[sheetName];
                            const rows = XLSX.utils.sheet_to_json(sheet, {
                                header: 1,
                                blankrows: false,
                                defval: ''
                            });

                            const parsedGuide = parseVoteGuideRows(rows);
                            if (parsedGuide.index.size === 0) {
                                attemptErrors.push(`${guideFile}: loaded but no valid VoteGuide rows were found`);
                                continue;
                            }

                            voteGuideBySessionAndVote = parsedGuide.index;
                            voteGuideBySessionAndLooseVote = parsedGuide.looseIndex;
                            loadedFromFile = guideFile;
                            break;
                        } catch (err) {
                            attemptErrors.push(`${guideFile}: ${err && err.message ? err.message : 'load error'}`);
                        }
                    }

                    if (!loadedFromFile) {
                        throw new Error(attemptErrors.join(' | ') || 'VoteGuide file not found');
                    }
                } catch (err) {
                    console.warn('VoteGuide could not be loaded; using spreadsheet descriptions only.', err);
                    voteGuideBySessionAndVote = new Map();
                    voteGuideBySessionAndLooseVote = new Map();
                } finally {
                    voteGuideLoadComplete = true;
                    voteGuideLoadPromise = null;
                }
            })();

            await voteGuideLoadPromise;
        }

        function parseRowsToData(rows, sessionMeta = {}) {
            if (!rows || rows.length <= HEADER_ROW_INDEX) {
                throw new Error('Spreadsheet does not contain expected header rows.');
            }

            LAST_VOTE_COL_INDEX = 100;
            const sessionId = sessionMeta.id || 'session';
            const sessionLabel = sessionMeta.label || 'Session';

            const titleRow = rows[TITLE_ROW_INDEX] || [];
            const descRow = rows[DESCRIPTION_ROW_INDEX] || [];

            const defaultHeaderRow = rows[HEADER_ROW_INDEX] || [];
            const possibleAltHeaderRow = rows[DESCRIPTION_ROW_INDEX] || [];
            const hasHeaderLabels = row =>
                String(row[PRECINCT_COL_INDEX] || '').trim().toUpperCase() === 'PRECINCT' &&
                String(row[NAME_COL_INDEX] || '').trim().toUpperCase() === 'NAME';
            const looksLikeDataRow = row => {
                const precinct = String(row[PRECINCT_COL_INDEX] || '').trim();
                const name = String(row[NAME_COL_INDEX] || '').trim();
                const upperPrecinct = precinct.toUpperCase();
                const precinctNum = parseInt(precinct, 10);
                const isNumericPrecinct = !isNaN(precinctNum);
                const isAL = upperPrecinct === 'AL';
                return !!name && (isNumericPrecinct || isAL);
            };

            let effectiveHeaderRowIndex = HEADER_ROW_INDEX;
            let effectiveFirstDataRowIndex = FIRST_DATA_ROW_INDEX;
            if (
                !hasHeaderLabels(defaultHeaderRow) &&
                hasHeaderLabels(possibleAltHeaderRow) &&
                looksLikeDataRow(defaultHeaderRow)
            ) {
                effectiveHeaderRowIndex = DESCRIPTION_ROW_INDEX;
                effectiveFirstDataRowIndex = HEADER_ROW_INDEX;
            }

            const headerRow = rows[effectiveHeaderRowIndex] || [];
            const maxPossibleCol = Math.max(titleRow.length, descRow.length, headerRow.length);

            let lastColWithTitle = FIRST_VOTE_COL_INDEX;
            for (let col = FIRST_VOTE_COL_INDEX; col < maxPossibleCol; col++) {
                const possibleTitle = String(titleRow[col] || headerRow[col] || '').trim();
                if (possibleTitle) {
                    lastColWithTitle = col;
                }
            }
            LAST_VOTE_COL_INDEX = lastColWithTitle;

            const parsedVotes = [];
            for (let col = FIRST_VOTE_COL_INDEX; col <= LAST_VOTE_COL_INDEX; col++) {
                const title = String(titleRow[col] || headerRow[col] || '').trim();
                if (!title) continue;
                const guideDetails = getVoteGuideDetails(sessionId, title);
                const descriptionFromSheet = String(descRow[col] || '').trim();
                parsedVotes.push({
                    id: `${sessionId}::${col}`,
                    sessionId,
                    sessionLabel,
                    colIndex: col,
                    title,
                    night: guideDetails ? String(guideDetails.night || '').trim() : '',
                    description: guideDetails && guideDetails.description
                        ? String(guideDetails.description).trim()
                        : descriptionFromSheet,
                    links: guideDetails && Array.isArray(guideDetails.links)
                        ? guideDetails.links
                        : [],
                    isTerminateDebate: isTerminateDebateVote(title)
                });
            }

            const parsedMembers = [];
            const parsedVotingData = {};
            const canonicalMembers = {};
            let lastMemberDataRowIndex = effectiveFirstDataRowIndex - 1;

            for (let r = effectiveFirstDataRowIndex; r < rows.length; r++) {
                const row = rows[r] || [];
                const name = String(row[NAME_COL_INDEX] || '').trim();
                const precinct = String(row[PRECINCT_COL_INDEX] || '').trim();

                if (!name && !precinct) continue;
                if (!name) continue;

                const upperName = name.toUpperCase();
                const upperPrecinct = precinct.toUpperCase();
                if (DISALLOWED_MEMBER_NAMES.has(upperName) || upperName.startsWith('TOTAL')) continue;

                const precinctNum = parseInt(precinct, 10);
                const isNumericPrecinct = !isNaN(precinctNum);
                const isAL = upperPrecinct === 'AL';
                if (!isNumericPrecinct && !isAL) continue;

                const memberKey = `${name} (Precinct ${precinct})`;
                const canonicalKey = canonicalMemberKey(name, precinct);
                const voteMapByTitle = {};
                const voteMapById = {};

                parsedVotes.forEach(vote => {
                    const normalized = normalizeVote(row[vote.colIndex]);
                    voteMapByTitle[vote.title] = normalized;
                    voteMapById[vote.id] = normalized;
                });

                parsedMembers.push({ name, precinct, key: memberKey });
                parsedVotingData[memberKey] = {
                    precinct,
                    votes: voteMapByTitle
                };
                lastMemberDataRowIndex = r;

                canonicalMembers[canonicalKey] = {
                    name,
                    precinct,
                    memberKey,
                    votesById: voteMapById
                };
            }

            const voteResultsByCol = extractVoteResultsByColumn(
                rows,
                lastMemberDataRowIndex + 1,
                LAST_VOTE_COL_INDEX
            );
            parsedVotes.forEach(vote => {
                vote.result = voteResultsByCol[vote.colIndex] || '';
            });

            return {
                id: sessionId,
                label: sessionLabel,
                file: sessionMeta.file || '',
                votes: parsedVotes,
                members: parsedMembers,
                votingData: parsedVotingData,
                canonicalMembers
            };
        }

        function parseWorkbookArrayBuffer(arrayBuffer, sessionMeta = {}) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, {
                header: 1,
                blankrows: false,
                defval: ''
            });
            return parseRowsToData(rows, sessionMeta);
        }

        async function fetchAndParseSpreadsheet(sessionMeta) {
            const response = await fetch(getSpreadsheetRawURL(sessionMeta.file));
            if (!response.ok) {
                throw new Error(`HTTP ${response.status} ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            return parseWorkbookArrayBuffer(arrayBuffer, sessionMeta);
        }

        async function loadVotingDataFromExcel() {
            try {
                if (loadingEl) loadingEl.textContent = 'Loading voting data from spreadsheet...';
                await ensureVoteGuideLoaded();
                const parsed = await fetchAndParseSpreadsheet(getCurrentSpreadsheetMeta());

                votes = parsed.votes.map(vote => ({
                    colIndex: vote.colIndex,
                    title: vote.title,
                    description: vote.description,
                    links: vote.links || [],
                    night: vote.night || '',
                    result: vote.result || ''
                }));
                members = parsed.members;
                votingData = parsed.votingData;

                initializeApp();
            } catch (err) {
                console.error(err);
                if (loadingEl) loadingEl.textContent = `Error loading spreadsheet: ${err.message}`;
            }
        }

        /****************************************************
         * INITIALIZATION & DROPDOWNS
         ****************************************************/

        function initializeApp() {
            members.sort((a, b) => {
                const pa = precinctSortValue(a.precinct);
                const pb = precinctSortValue(b.precinct);
                if (pa !== pb) return pa - pb;
                return a.name.localeCompare(b.name);
            });

            populateDropdowns();

            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';

            if (votes.length > 0) {
                const voteSelect = document.getElementById('vote-select');
                if (voteSelect) voteSelect.value = votes[0].title;
                updateVoteResults();
            }

            const memberSelect = document.getElementById('member-select');
            if (memberSelect && memberSelect.value && votingData[memberSelect.value]) {
                updateMemberResults();
            }
        }

        function populateMemberDropdown() {
            const memberSelect = document.getElementById('member-select');
            if (!memberSelect) return;

            const sortByPrecinctCheckbox = document.getElementById('sort-by-precinct-member');
            const sortByPrecinct = sortByPrecinctCheckbox ? sortByPrecinctCheckbox.checked : false;
            const currentValue = memberSelect.value;
            const sortedMembers = [...members];

            sortedMembers.sort((a, b) => {
                if (sortByPrecinct) {
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                }
                return a.name.localeCompare(b.name);
            });

            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member.key;
                option.textContent = member.key;
                memberSelect.appendChild(option);
            });

            if (currentValue && Array.from(memberSelect.options).some(opt => opt.value === currentValue)) {
                memberSelect.value = currentValue;
            } else if (memberSelect.options.length > 0) {
                memberSelect.value = memberSelect.options[0].value;
            }
        }

        function populateDropdowns() {
            const voteSelect = document.getElementById('vote-select');
            if (!voteSelect) return;

            voteSelect.innerHTML = '';
            votes.forEach(vote => {
                const option = document.createElement('option');
                option.value = vote.title;
                option.textContent = vote.title;
                voteSelect.appendChild(option);
            });

            populateMemberDropdown();
        }

        /****************************************************
         * VIEW BY VOTE
         ****************************************************/

        function updateVoteResults() {
            const voteSelect = document.getElementById('vote-select');
            const sortByNameCheckbox = document.getElementById('sort-by-name-vote');
            if (!voteSelect || !sortByNameCheckbox) return;

            const selectedVote = voteSelect.value;
            const sortByNameOnly = sortByNameCheckbox.checked;
            const resultsDiv = document.getElementById('vote-results');
            if (!resultsDiv) return;

            const selectedVoteDetails = votes.find(v => v.title === selectedVote);
            const description = selectedVoteDetails ? selectedVoteDetails.description : '';
            const links = selectedVoteDetails && Array.isArray(selectedVoteDetails.links)
                ? selectedVoteDetails.links
                : [];
            const night = selectedVoteDetails ? selectedVoteDetails.night : '';
            const voteResult = selectedVoteDetails ? selectedVoteDetails.result : '';
            const sessionLabel = getCurrentSpreadsheetMeta().label || '';
            const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };

            members.forEach(member => {
                const voteVal = votingData[member.key].votes[selectedVote];
                const normalizedVote = voteVal ? voteVal.toUpperCase() : 'NOVOTE';
                if (normalizedVote === 'YES') {
                    voteGroups.YES.push(member);
                } else if (normalizedVote === 'NO') {
                    voteGroups.NO.push(member);
                } else if (normalizedVote === 'ABSTAIN') {
                    voteGroups.ABSTAIN.push(member);
                } else {
                    voteGroups.NoVote.push(member);
                }
            });

            Object.keys(voteGroups).forEach(voteType => {
                voteGroups[voteType].sort((a, b) => {
                    if (sortByNameOnly) return a.name.localeCompare(b.name);
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                    return a.name.localeCompare(b.name);
                });
            });

            const totalVotes = voteGroups.YES.length + voteGroups.NO.length;
            const percentages = {
                YES: totalVotes > 0 ? ((voteGroups.YES.length / totalVotes) * 100).toFixed(1) : '0.0',
                NO: totalVotes > 0 ? ((voteGroups.NO.length / totalVotes) * 100).toFixed(1) : '0.0'
            };

            resultsDiv.replaceChildren();

            if (selectedVoteDetails || description || links.length > 0) {
                const descriptionEl = document.createElement('div');
                descriptionEl.className = 'article-description';
                const summaryEl = document.createElement('div');
                summaryEl.className = 'article-summary-line';

                const summaryValues = [
                    { text: selectedVote || 'Vote title unavailable', className: 'article-summary-primary' },
                    { text: `Session: ${sessionLabel || 'Not listed'}` },
                    { text: `Night/Date: ${night || 'Not listed'}` },
                    { text: `Vote: ${voteResult || 'Not listed'}` }
                ];

                summaryValues.forEach((part, index) => {
                    const valueEl = document.createElement('span');
                    valueEl.textContent = part.text;
                    if (part.className) valueEl.className = part.className;
                    summaryEl.appendChild(valueEl);

                    if (index < summaryValues.length - 1) {
                        const sepEl = document.createElement('span');
                        sepEl.className = 'article-summary-separator';
                        sepEl.textContent = '•';
                        summaryEl.appendChild(sepEl);
                    }
                });
                descriptionEl.appendChild(summaryEl);

                if (description) {
                    const descriptionBodyEl = document.createElement('div');
                    descriptionBodyEl.textContent = description;
                    descriptionEl.appendChild(descriptionBodyEl);
                }

                const linksEl = buildArticleLinksElement(links);
                if (linksEl) {
                    descriptionEl.appendChild(linksEl);
                }
                resultsDiv.appendChild(descriptionEl);
            }

            const resultsGridEl = document.createElement('div');
            resultsGridEl.className = 'results';

            function appendMemberColumn(columnClass, title, memberList) {
                const columnEl = document.createElement('div');
                columnEl.className = `vote-column ${columnClass}`;

                const headerEl = document.createElement('h3');
                headerEl.textContent = title;
                columnEl.appendChild(headerEl);

                const listEl = document.createElement('div');
                listEl.className = 'member-list';

                memberList.forEach(member => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'member-item';

                    const precinctEl = document.createElement('span');
                    precinctEl.className = 'precinct-label';
                    precinctEl.textContent = `${formatPrecinctLabel(member.precinct)}:`;
                    itemEl.appendChild(precinctEl);
                    itemEl.appendChild(document.createTextNode(` ${member.name}`));

                    listEl.appendChild(itemEl);
                });

                columnEl.appendChild(listEl);
                resultsGridEl.appendChild(columnEl);
            }

            appendMemberColumn('yes', `Yes (${voteGroups.YES.length}, ${percentages.YES}%)`, voteGroups.YES);
            appendMemberColumn('no', `No (${voteGroups.NO.length}, ${percentages.NO}%)`, voteGroups.NO);
            appendMemberColumn('abstain', `Abstain (${voteGroups.ABSTAIN.length})`, voteGroups.ABSTAIN);
            appendMemberColumn('novote', `Vote Not Recorded (${voteGroups.NoVote.length})`, voteGroups.NoVote);

            resultsDiv.appendChild(resultsGridEl);
        }

        /****************************************************
         * VIEW BY MEMBER
         ****************************************************/

        function updateMemberResults() {
            const memberSelect = document.getElementById('member-select');
            if (!memberSelect) return;

            const selectedMember = memberSelect.value;
            const resultsDiv = document.getElementById('member-results');
            if (!resultsDiv) return;
            if (!selectedMember || !votingData[selectedMember]) return;

            const memberVotes = votingData[selectedMember].votes;
            const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };

            votes.forEach(vote => {
                const voteValue = memberVotes[vote.title];
                const normalizedVote = voteValue ? voteValue.toUpperCase() : 'NOVOTE';
                const voteWithDesc = {
                    title: vote.title,
                    description: vote.description,
                    result: vote.result || '',
                    links: vote.links || []
                };
                if (normalizedVote === 'YES') {
                    voteGroups.YES.push(voteWithDesc);
                } else if (normalizedVote === 'NO') {
                    voteGroups.NO.push(voteWithDesc);
                } else if (normalizedVote === 'ABSTAIN') {
                    voteGroups.ABSTAIN.push(voteWithDesc);
                } else {
                    voteGroups.NoVote.push(voteWithDesc);
                }
            });

            const sortByArticle = (a, b) => {
                const aIsTerminate = a.title.toLowerCase().includes('terminate debate');
                const bIsTerminate = b.title.toLowerCase().includes('terminate debate');
                if (aIsTerminate && !bIsTerminate) return 1;
                if (!aIsTerminate && bIsTerminate) return -1;

                const aMatch = a.title.match(/Article (\d+)/i);
                const bMatch = b.title.match(/Article (\d+)/i);
                if (aMatch && bMatch) return parseInt(aMatch[1], 10) - parseInt(bMatch[1], 10);
                return a.title.localeCompare(b.title);
            };

            Object.keys(voteGroups).forEach(voteType => {
                voteGroups[voteType].sort(sortByArticle);
            });

            const total = votes.length;
            const percentages = {
                YES: total > 0 ? ((voteGroups.YES.length / total) * 100).toFixed(1) : '0.0',
                NO: total > 0 ? ((voteGroups.NO.length / total) * 100).toFixed(1) : '0.0',
                ABSTAIN: total > 0 ? ((voteGroups.ABSTAIN.length / total) * 100).toFixed(1) : '0.0',
                NoVote: total > 0 ? ((voteGroups.NoVote.length / total) * 100).toFixed(1) : '0.0'
            };

            resultsDiv.replaceChildren();

            function appendArticleColumn(columnClass, title, voteList) {
                const columnEl = document.createElement('div');
                columnEl.className = `vote-column ${columnClass}`;

                const headerEl = document.createElement('h3');
                headerEl.textContent = title;
                columnEl.appendChild(headerEl);

                const listEl = document.createElement('div');
                listEl.className = 'article-list';

                voteList.forEach(vote => {
                    const wrapperEl = document.createElement('div');
                    wrapperEl.className = 'article-item-with-desc';

                    const detailsEl = document.createElement('details');
                    detailsEl.className = 'article-detail';

                    const titleEl = document.createElement('summary');
                    titleEl.className = 'article-title article-title-toggle';
                    titleEl.textContent = vote.title;
                    detailsEl.appendChild(titleEl);

                    const detailBodyEl = document.createElement('div');
                    detailBodyEl.className = 'article-detail-body';

                    if (vote.result) {
                        const resultEl = document.createElement('div');
                        resultEl.className = 'article-vote-result';
                        resultEl.textContent = `Vote: ${vote.result}`;
                        detailBodyEl.appendChild(resultEl);
                    }

                    if (vote.description) {
                        const descEl = document.createElement('div');
                        descEl.className = 'article-desc';
                        descEl.textContent = vote.description;
                        detailBodyEl.appendChild(descEl);
                    }

                    const linksEl = buildArticleLinksElement(vote.links);
                    if (linksEl) {
                        detailBodyEl.appendChild(linksEl);
                    }

                    detailsEl.appendChild(detailBodyEl);
                    wrapperEl.appendChild(detailsEl);

                    listEl.appendChild(wrapperEl);
                });

                columnEl.appendChild(listEl);
                resultsDiv.appendChild(columnEl);
            }

            appendArticleColumn('yes', `Yes (${voteGroups.YES.length}, ${percentages.YES}%)`, voteGroups.YES);
            appendArticleColumn('no', `No (${voteGroups.NO.length}, ${percentages.NO}%)`, voteGroups.NO);
            appendArticleColumn('abstain', `Abstain (${voteGroups.ABSTAIN.length}, ${percentages.ABSTAIN}%)`, voteGroups.ABSTAIN);
            appendArticleColumn('novote', `Vote Not Recorded (${voteGroups.NoVote.length}, ${percentages.NoVote}%)`, voteGroups.NoVote);
        }

        /****************************************************
         * VOTER CLUSTERING — DATA LOADING
         ****************************************************/

        function setClusteringStatus(message, isError = false) {
            if (!clusterStatusEl) return;
            clusterStatusEl.textContent = message;
            clusterStatusEl.classList.toggle('error', isError);
        }

        function setPanelMessage(panelEl, message) {
            if (!panelEl) return;
            panelEl.replaceChildren();
            const msg = document.createElement('div');
            msg.className = 'cluster-message';
            msg.textContent = message;
            panelEl.appendChild(msg);
        }

        function clearClusterPlot() {
            if (!clusterPlotEl || typeof Plotly === 'undefined') return;
            try {
                Plotly.purge(clusterPlotEl);
            } catch (err) {
                console.warn('Unable to clear clustering plot:', err);
            }
        }

        function initializeClusteringControls() {
            if (clusteringControlsInitialized) return;

            const sessionsContainer = document.getElementById('cluster-session-checkboxes');
            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            const terminateWeightSlider = document.getElementById('cluster-terminate-weight');
            const terminateWeightValue = document.getElementById('cluster-terminate-weight-value');
            const colorBySelect = document.getElementById('cluster-color-by');
            const memberSearchInput = document.getElementById('cluster-member-search');
            const memberSearchButton = document.getElementById('cluster-member-search-go');

            if (
                !sessionsContainer ||
                !minSessionsSelect ||
                !terminateWeightSlider ||
                !terminateWeightValue ||
                !colorBySelect ||
                !memberSearchInput ||
                !memberSearchButton
            ) {
                return;
            }

            const defaultSelectedSessionCount = Math.min(4, SESSION_FILES.length);
            const defaultMinimumSessions = Math.min(4, SESSION_FILES.length);

            [...SESSION_FILES].reverse().forEach((session, index) => {
                const optionLabel = document.createElement('label');
                optionLabel.className = 'session-option';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = index < defaultSelectedSessionCount;
                checkbox.value = session.id;
                checkbox.setAttribute('data-session-id', session.id);

                const text = document.createElement('span');
                text.textContent = session.label;

                optionLabel.appendChild(checkbox);
                optionLabel.appendChild(text);
                sessionsContainer.appendChild(optionLabel);
            });

            minSessionsSelect.replaceChildren();
            for (let i = 1; i <= SESSION_FILES.length; i++) {
                const option = document.createElement('option');
                option.value = String(i);
                option.textContent = String(i);
                if (i === defaultMinimumSessions) option.selected = true;
                minSessionsSelect.appendChild(option);
            }

            terminateWeightSlider.value = '0';
            terminateWeightValue.textContent = Number.parseFloat(terminateWeightSlider.value).toFixed(1);
            colorBySelect.value = 'none';

            sessionsContainer.addEventListener('change', event => {
                if (event.target && event.target.matches('input[type="checkbox"]')) {
                    syncMinimumSessionsControl();
                    runClusteringAnalysis();
                }
            });

            minSessionsSelect.addEventListener('change', runClusteringAnalysis);
            colorBySelect.addEventListener('change', runClusteringAnalysis);
            terminateWeightSlider.addEventListener('input', () => {
                terminateWeightValue.textContent = Number.parseFloat(terminateWeightSlider.value).toFixed(1);
                debouncedRunClusteringAnalysis();
            });

            memberSearchButton.addEventListener('click', selectClusterMemberFromSearch);
            memberSearchInput.addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    selectClusterMemberFromSearch();
                }
            });

            clusteringControlsInitialized = true;
            syncMinimumSessionsControl();
        }

        function getSelectedClusteringSessionIds() {
            const checked = document.querySelectorAll('#cluster-session-checkboxes input[type="checkbox"]:checked');
            return new Set(Array.from(checked).map(input => input.value));
        }

        function syncMinimumSessionsControl() {
            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            if (!minSessionsSelect) return;

            const selectedCount = getSelectedClusteringSessionIds().size;
            const maxAllowed = Math.max(1, selectedCount);
            const current = Number.parseInt(minSessionsSelect.value, 10) || 1;

            Array.from(minSessionsSelect.options).forEach(option => {
                const value = Number.parseInt(option.value, 10);
                option.disabled = value > maxAllowed;
            });

            if (current > maxAllowed) {
                minSessionsSelect.value = String(maxAllowed);
            }
        }

        function debouncedRunClusteringAnalysis() {
            if (clusteringDebounceTimer) clearTimeout(clusteringDebounceTimer);
            clusteringDebounceTimer = window.setTimeout(runClusteringAnalysis, 200);
        }

        async function ensureClusteringDataLoaded() {
            initializeClusteringControls();

            if (clusteringSessionsCache) {
                runClusteringAnalysis();
                return;
            }
            if (clusteringLoadPromise) {
                await clusteringLoadPromise;
                return;
            }

            const total = SESSION_FILES.length;
            let loadedCount = 0;
            setClusteringStatus(`Loading clustering data (0 of ${total})...`);
            setPanelMessage(clusterMemberDetailEl, 'Loading all sessions...');
            setPanelMessage(clusterNeighborsEl, 'Loading all sessions...');
            await ensureVoteGuideLoaded();

            clusteringLoadPromise = Promise.all(
                SESSION_FILES.map(async session => {
                    try {
                        return await fetchAndParseSpreadsheet(session);
                    } catch (err) {
                        throw new Error(`${session.label}: ${err.message}`);
                    } finally {
                        loadedCount += 1;
                        setClusteringStatus(`Loading clustering data (${loadedCount} of ${total})...`);
                    }
                })
            ).then(results => {
                clusteringSessionsCache = results;
                setClusteringStatus(`Loaded ${total} sessions. Rendering clustering view...`);
                runClusteringAnalysis();
            }).catch(err => {
                console.error(err);
                clearClusterPlot();
                setClusteringStatus(`Error loading clustering data: ${err.message}`, true);
                setPanelMessage(clusterMemberDetailEl, 'Clustering data failed to load.');
                setPanelMessage(clusterNeighborsEl, 'Clustering data failed to load.');
                setPanelMessage(clusterAxisInfoEl, 'Clustering data failed to load.');
            }).finally(() => {
                clusteringLoadPromise = null;
            });

            await clusteringLoadPromise;
        }

        /****************************************************
         * VOTER CLUSTERING — MATRIX BUILDING
         ****************************************************/

        function buildClusteringAnalysis(selectedSessions, minSessions, terminateWeight) {
            if (!selectedSessions || selectedSessions.length === 0) {
                return { error: 'Select at least one session to run clustering.' };
            }

            const allColumns = [];
            const profileMap = new Map();

            selectedSessions.forEach(session => {
                session.votes.forEach(vote => allColumns.push(vote));

                Object.entries(session.canonicalMembers).forEach(([canonicalKey, memberEntry]) => {
                    if (!profileMap.has(canonicalKey)) {
                        profileMap.set(canonicalKey, {
                            canonicalKey,
                            name: memberEntry.name,
                            precinct: memberEntry.precinct,
                            sessions: new Set(),
                            rawVotesById: {}
                        });
                    }

                    const profile = profileMap.get(canonicalKey);
                    profile.name = memberEntry.name;
                    profile.precinct = memberEntry.precinct;
                    profile.sessions.add(session.id);

                    Object.entries(memberEntry.votesById).forEach(([voteId, voteValue]) => {
                        profile.rawVotesById[voteId] = voteValue;
                    });
                });
            });

            const includedProfiles = Array.from(profileMap.values())
                .filter(profile => profile.sessions.size >= minSessions)
                .sort((a, b) => {
                    const pa = precinctSortValue(a.precinct);
                    const pb = precinctSortValue(b.precinct);
                    if (pa !== pb) return pa - pb;
                    return a.name.localeCompare(b.name);
                });

            if (includedProfiles.length === 0) {
                return { error: 'No members match the current minimum sessions setting.' };
            }

            const keptColumns = allColumns.filter(column => {
                let nonMissing = 0;
                includedProfiles.forEach(profile => {
                    const voteValue = profile.rawVotesById[column.id] || 'NoVote';
                    if (voteValue !== 'NoVote') nonMissing += 1;
                });
                return (nonMissing / includedProfiles.length) >= 0.2;
            });

            if (keptColumns.length === 0) {
                return { error: 'No vote columns remain after missing-data filtering.' };
            }

            const membersForPlot = [];
            const matrixRawWithNaN = [];
            const matrixImputed = [];
            const memberIndexByKey = {};

            includedProfiles.forEach((profile, rowIndex) => {
                const rawRow = [];
                const imputedRow = [];
                let votesCast = 0;

                keptColumns.forEach(column => {
                    const voteValue = profile.rawVotesById[column.id] || 'NoVote';
                    if (voteValue === 'NoVote') {
                        rawRow.push(NaN);
                        imputedRow.push(0);
                        return;
                    }

                    let numeric = voteToNumeric(voteValue);
                    if (column.isTerminateDebate) numeric *= terminateWeight;
                    rawRow.push(numeric);
                    imputedRow.push(numeric);
                    votesCast += 1;
                });

                matrixRawWithNaN.push(rawRow);
                matrixImputed.push(imputedRow);

                const memberRecord = {
                    canonicalKey: profile.canonicalKey,
                    name: profile.name,
                    precinct: profile.precinct,
                    sessionsAttended: profile.sessions.size,
                    votesCast,
                    rawVotesById: profile.rawVotesById
                };
                membersForPlot.push(memberRecord);
                memberIndexByKey[profile.canonicalKey] = rowIndex;
            });

            const pcaResult = computePCA2D(matrixImputed);
            if (pcaResult.error) return { error: pcaResult.error };

            membersForPlot.forEach((member, index) => {
                member.x = pcaResult.coordinates[index].x;
                member.y = pcaResult.coordinates[index].y;
            });

            return {
                members: membersForPlot,
                columns: keptColumns,
                matrixRawWithNaN,
                matrixImputed,
                memberIndexByKey,
                selectedSessionsCount: selectedSessions.length,
                varianceExplained: pcaResult.varianceExplained,
                componentVectors: pcaResult.componentVectors,
                axisInterpretation: buildAxisInterpretation(keptColumns, pcaResult.componentVectors)
            };
        }

        /****************************************************
         * VOTER CLUSTERING — PCA
         ****************************************************/

        function dotProduct(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
            return sum;
        }

        function vectorNorm(vector) {
            return Math.sqrt(dotProduct(vector, vector));
        }

        function multiplyMatrixVector(matrix, vector) {
            return matrix.map(row => dotProduct(row, vector));
        }

        function orthogonalizeVector(vector, basis) {
            const projection = dotProduct(vector, basis);
            return vector.map((value, i) => value - (projection * basis[i]));
        }

        function normalizeVector(vector) {
            const norm = vectorNorm(vector);
            if (norm < 1e-12) return null;
            return vector.map(value => value / norm);
        }

        function rayleighQuotient(matrix, vector) {
            const multiplied = multiplyMatrixVector(matrix, vector);
            return dotProduct(vector, multiplied);
        }

        function powerIteration(matrix, maxIterations = 250, tolerance = 1e-9) {
            const n = matrix.length;
            if (n === 0) return null;

            let vector = Array.from({ length: n }, (_, i) => (i === 0 ? 1 : 0));
            const normalizedSeed = normalizeVector(vector);
            if (!normalizedSeed) return null;
            vector = normalizedSeed;

            for (let iter = 0; iter < maxIterations; iter++) {
                const multiplied = multiplyMatrixVector(matrix, vector);
                const normalized = normalizeVector(multiplied);
                if (!normalized) return null;

                const delta = normalized.reduce((sum, value, i) => sum + Math.abs(value - vector[i]), 0);
                vector = normalized;
                if (delta < tolerance) break;
            }

            return {
                vector,
                eigenvalue: rayleighQuotient(matrix, vector)
            };
        }

        function deflateMatrix(matrix, vector, eigenvalue) {
            return matrix.map((row, i) =>
                row.map((value, j) => value - (eigenvalue * vector[i] * vector[j]))
            );
        }

        function buildFallbackUnitVector(length, avoidVector) {
            for (let i = 0; i < length; i++) {
                let candidate = Array.from({ length }, (_, idx) => (idx === i ? 1 : 0));
                if (avoidVector) {
                    candidate = orthogonalizeVector(candidate, avoidVector);
                }
                const normalized = normalizeVector(candidate);
                if (normalized) return normalized;
            }
            return Array.from({ length }, (_, idx) => (idx === 0 ? 1 : 0));
        }

        function buildCovarianceMatrix(centeredMatrix) {
            const rowCount = centeredMatrix.length;
            const colCount = centeredMatrix[0].length;
            const covariance = Array.from({ length: colCount }, () => Array(colCount).fill(0));
            const denom = rowCount > 1 ? rowCount - 1 : 1;

            for (let r = 0; r < rowCount; r++) {
                const row = centeredMatrix[r];
                for (let i = 0; i < colCount; i++) {
                    const xi = row[i];
                    for (let j = i; j < colCount; j++) {
                        covariance[i][j] += xi * row[j];
                    }
                }
            }

            for (let i = 0; i < colCount; i++) {
                for (let j = i; j < colCount; j++) {
                    const value = covariance[i][j] / denom;
                    covariance[i][j] = value;
                    covariance[j][i] = value;
                }
            }
            return covariance;
        }

        function computePCA2D(matrix) {
            const rowCount = matrix.length;
            const colCount = rowCount > 0 ? matrix[0].length : 0;
            if (rowCount === 0 || colCount === 0) {
                return { error: 'Not enough data to run PCA.' };
            }

            const colMeans = Array(colCount).fill(0);
            for (let c = 0; c < colCount; c++) {
                let sum = 0;
                for (let r = 0; r < rowCount; r++) sum += matrix[r][c];
                colMeans[c] = sum / rowCount;
            }

            const centeredMatrix = matrix.map(row =>
                row.map((value, idx) => value - colMeans[idx])
            );
            const covariance = buildCovarianceMatrix(centeredMatrix);

            const totalVariance = covariance.reduce((sum, row, index) => sum + row[index], 0);
            let first = powerIteration(covariance);
            if (!first || !Number.isFinite(first.eigenvalue)) {
                first = {
                    vector: buildFallbackUnitVector(colCount),
                    eigenvalue: 0
                };
            }
            first.eigenvalue = rayleighQuotient(covariance, first.vector);

            const deflated = deflateMatrix(covariance, first.vector, first.eigenvalue);
            let second = powerIteration(deflated);
            if (!second || !Number.isFinite(second.eigenvalue)) {
                second = {
                    vector: buildFallbackUnitVector(colCount, first.vector),
                    eigenvalue: 0
                };
            } else {
                const orthogonalized = orthogonalizeVector(second.vector, first.vector);
                const normalized = normalizeVector(orthogonalized);
                second.vector = normalized || buildFallbackUnitVector(colCount, first.vector);
            }
            second.eigenvalue = rayleighQuotient(covariance, second.vector);

            const rawCoordinates = centeredMatrix.map(row => ({
                x: dotProduct(row, first.vector),
                y: dotProduct(row, second.vector)
            }));

            const maxAbsX = Math.max(...rawCoordinates.map(point => Math.abs(point.x)), 0);
            const maxAbsY = Math.max(...rawCoordinates.map(point => Math.abs(point.y)), 0);
            const scaleX = maxAbsX > 0 ? maxAbsX : 1;
            const scaleY = maxAbsY > 0 ? maxAbsY : 1;
            const coordinates = rawCoordinates.map(point => ({
                x: point.x / scaleX,
                y: point.y / scaleY
            }));

            return {
                coordinates,
                componentVectors: [first.vector, second.vector],
                varianceExplained: {
                    pc1: totalVariance > 0 ? (Math.max(0, first.eigenvalue) / totalVariance) * 100 : 0,
                    pc2: totalVariance > 0 ? (Math.max(0, second.eigenvalue) / totalVariance) * 100 : 0
                }
            };
        }

        function buildAxisInterpretation(columns, componentVectors) {
            return componentVectors.map((vector, idx) => {
                const loadings = columns.map((column, colIndex) => ({
                    column,
                    value: vector[colIndex]
                }));

                return {
                    component: idx + 1,
                    negative: [...loadings].sort((a, b) => a.value - b.value).slice(0, 5),
                    positive: [...loadings].sort((a, b) => b.value - a.value).slice(0, 5)
                };
            });
        }

        /****************************************************
         * VOTER CLUSTERING — RENDERING
         ****************************************************/

        function runClusteringAnalysis() {
            if (!clusteringSessionsCache) return;

            const minSessionsSelect = document.getElementById('cluster-min-sessions');
            const terminateWeightSlider = document.getElementById('cluster-terminate-weight');
            const colorBySelect = document.getElementById('cluster-color-by');
            if (!minSessionsSelect || !terminateWeightSlider || !colorBySelect) return;

            const selectedSessionIds = getSelectedClusteringSessionIds();
            if (selectedSessionIds.size === 0) {
                clearClusterPlot();
                setClusteringStatus('Select at least one session to run clustering.');
                setPanelMessage(clusterMemberDetailEl, 'Select at least one session to run clustering.');
                setPanelMessage(clusterNeighborsEl, 'Select at least one session to run clustering.');
                setPanelMessage(clusterAxisInfoEl, 'Select at least one session to run clustering.');
                selectedClusterMemberKey = null;
                clusteringAnalysisState = null;
                return;
            }

            const selectedSessions = clusteringSessionsCache.filter(session => selectedSessionIds.has(session.id));
            const selectedSessionCount = selectedSessions.length;
            let minSessions = Number.parseInt(minSessionsSelect.value, 10) || 1;
            if (minSessions > selectedSessionCount) {
                minSessions = selectedSessionCount;
                minSessionsSelect.value = String(minSessions);
            }

            const terminateWeight = Number.parseFloat(terminateWeightSlider.value);
            const colorBy = colorBySelect.value;
            const analysis = buildClusteringAnalysis(selectedSessions, minSessions, terminateWeight);

            if (analysis.error) {
                clearClusterPlot();
                setClusteringStatus(analysis.error);
                setPanelMessage(clusterMemberDetailEl, analysis.error);
                setPanelMessage(clusterNeighborsEl, analysis.error);
                setPanelMessage(clusterAxisInfoEl, analysis.error);
                selectedClusterMemberKey = null;
                clusteringAnalysisState = null;
                return;
            }

            clusteringAnalysisState = analysis;
            renderClusteringPlot(analysis, colorBy);
            renderAxisInterpretation(analysis);
            populateClusterMemberSearch(analysis);

            if (selectedClusterMemberKey && analysis.memberIndexByKey[selectedClusterMemberKey] !== undefined) {
                renderClusteringMemberSelection(selectedClusterMemberKey);
            } else {
                selectedClusterMemberKey = null;
                setPanelMessage(clusterMemberDetailEl, 'Click a dot to view this member\'s aggregated voting summary.');
                setPanelMessage(clusterNeighborsEl, 'Click a dot to view the 10 most similar members.');
            }

            setClusteringStatus(
                `Showing ${analysis.members.length} members from ${selectedSessionCount} sessions across ${analysis.columns.length} vote columns.`
            );
        }

        function getClusterMemberSearchLabel(member) {
            return `${member.name} (${formatPrecinctLabel(member.precinct)})`;
        }

        function populateClusterMemberSearch(analysis) {
            const datalist = document.getElementById('cluster-member-options');
            const input = document.getElementById('cluster-member-search');
            if (!datalist || !input) return;

            clusterMemberSearchLabelToKey.clear();
            clusterMemberSearchKeyToLabel.clear();
            datalist.replaceChildren();

            const sortedMembers = [...analysis.members].sort((a, b) => {
                const nameDiff = a.name.localeCompare(b.name);
                if (nameDiff !== 0) return nameDiff;
                return precinctSortValue(a.precinct) - precinctSortValue(b.precinct);
            });

            sortedMembers.forEach(member => {
                const baseLabel = getClusterMemberSearchLabel(member);
                let label = baseLabel;
                if (clusterMemberSearchLabelToKey.has(label)) {
                    label = `${baseLabel} [${member.canonicalKey}]`;
                }

                clusterMemberSearchLabelToKey.set(label, member.canonicalKey);
                clusterMemberSearchKeyToLabel.set(member.canonicalKey, label);

                const option = document.createElement('option');
                option.value = label;
                datalist.appendChild(option);
            });

            if (selectedClusterMemberKey && clusterMemberSearchKeyToLabel.has(selectedClusterMemberKey)) {
                input.value = clusterMemberSearchKeyToLabel.get(selectedClusterMemberKey);
            } else if (!input.value.trim()) {
                input.value = '';
            }
        }

        function selectClusterMemberFromSearch() {
            if (!clusteringAnalysisState) {
                setClusteringStatus('Load clustering data before searching for members.');
                return;
            }

            const input = document.getElementById('cluster-member-search');
            if (!input) return;

            const query = input.value.trim();
            if (!query) {
                setClusteringStatus('Enter a member name to search.');
                return;
            }

            let selectedKey = clusterMemberSearchLabelToKey.get(query) || null;
            let note = '';

            if (!selectedKey) {
                const queryLower = query.toLowerCase();
                const candidates = clusteringAnalysisState.members.filter(member => {
                    const label = getClusterMemberSearchLabel(member).toLowerCase();
                    return (
                        member.name.toLowerCase().includes(queryLower) ||
                        label.includes(queryLower)
                    );
                });

                if (candidates.length === 0) {
                    setClusteringStatus(`No member found for "${query}".`);
                    return;
                }

                candidates.sort((a, b) => {
                    const startsA = a.name.toLowerCase().startsWith(queryLower) ? 0 : 1;
                    const startsB = b.name.toLowerCase().startsWith(queryLower) ? 0 : 1;
                    if (startsA !== startsB) return startsA - startsB;
                    const nameDiff = a.name.localeCompare(b.name);
                    if (nameDiff !== 0) return nameDiff;
                    return precinctSortValue(a.precinct) - precinctSortValue(b.precinct);
                });

                selectedKey = candidates[0].canonicalKey;
                if (candidates.length > 1) {
                    note = ` (${candidates.length} matches, showing closest match)`;
                }
            }

            selectedClusterMemberKey = selectedKey;
            runClusteringAnalysis();
            if (clusterMemberSearchKeyToLabel.has(selectedKey)) {
                input.value = clusterMemberSearchKeyToLabel.get(selectedKey);
            }

            const selectedMember = clusteringAnalysisState.members[clusteringAnalysisState.memberIndexByKey[selectedKey]];
            if (selectedMember) {
                setClusteringStatus(`Selected ${selectedMember.name} (${formatPrecinctLabel(selectedMember.precinct)})${note}.`);
            }
        }

        function formatVoteLabelForPanel(column) {
            return `${column.title} (${column.sessionLabel})`;
        }

        function compareClusterVoteMeta(a, b) {
            const sessionDiff = (SESSION_ORDER_INDEX[a.sessionId] ?? 999) - (SESSION_ORDER_INDEX[b.sessionId] ?? 999);
            if (sessionDiff !== 0) return sessionDiff;

            const aTerminate = a.title.toLowerCase().includes('terminate debate');
            const bTerminate = b.title.toLowerCase().includes('terminate debate');
            if (aTerminate && !bTerminate) return 1;
            if (!aTerminate && bTerminate) return -1;

            const aMatch = a.title.match(/Article (\d+)/i);
            const bMatch = b.title.match(/Article (\d+)/i);
            if (aMatch && bMatch) return parseInt(aMatch[1], 10) - parseInt(bMatch[1], 10);
            return a.title.localeCompare(b.title);
        }

        function renderClusteringMemberSelection(canonicalKey) {
            if (!clusteringAnalysisState) return;

            const analysis = clusteringAnalysisState;
            const rowIndex = analysis.memberIndexByKey[canonicalKey];
            if (rowIndex === undefined) return;

            selectedClusterMemberKey = canonicalKey;
            const member = analysis.members[rowIndex];
            const searchInput = document.getElementById('cluster-member-search');
            if (searchInput && clusterMemberSearchKeyToLabel.has(canonicalKey)) {
                searchInput.value = clusterMemberSearchKeyToLabel.get(canonicalKey);
            }

            if (clusterMemberDetailEl) {
                clusterMemberDetailEl.replaceChildren();

                const meta = document.createElement('div');
                meta.className = 'cluster-member-meta';
                meta.textContent =
                    `${member.name} (${formatPrecinctLabel(member.precinct)}) • ` +
                    `${member.sessionsAttended} sessions attended • ${member.votesCast} recorded votes`;
                clusterMemberDetailEl.appendChild(meta);

                const voteGroups = { YES: [], NO: [], ABSTAIN: [], NoVote: [] };
                analysis.columns.forEach(column => {
                    const voteValue = member.rawVotesById[column.id] || 'NoVote';
                    if (voteValue === 'YES') {
                        voteGroups.YES.push(column);
                    } else if (voteValue === 'NO') {
                        voteGroups.NO.push(column);
                    } else if (voteValue === 'ABSTAIN') {
                        voteGroups.ABSTAIN.push(column);
                    } else {
                        voteGroups.NoVote.push(column);
                    }
                });

                Object.keys(voteGroups).forEach(groupKey => voteGroups[groupKey].sort(compareClusterVoteMeta));

                const total = analysis.columns.length;
                const resultsGrid = document.createElement('div');
                resultsGrid.className = 'results';

                function appendColumn(columnClass, title, items) {
                    const columnEl = document.createElement('div');
                    columnEl.className = `vote-column ${columnClass}`;

                    const percent = total > 0 ? ((items.length / total) * 100).toFixed(1) : '0.0';
                    const header = document.createElement('h3');
                    header.textContent = `${title} (${items.length}, ${percent}%)`;
                    columnEl.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'article-list';

                    items.forEach(columnMeta => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'article-item-with-desc';

                        const titleEl = document.createElement('div');
                        titleEl.className = 'article-title';
                        titleEl.textContent = formatVoteLabelForPanel(columnMeta);
                        wrapper.appendChild(titleEl);

                        if (columnMeta.description) {
                            const desc = document.createElement('div');
                            desc.className = 'article-desc';
                            desc.textContent = columnMeta.description;
                            wrapper.appendChild(desc);
                        }

                        const linksEl = buildArticleLinksElement(columnMeta.links);
                        if (linksEl) {
                            wrapper.appendChild(linksEl);
                        }

                        list.appendChild(wrapper);
                    });

                    columnEl.appendChild(list);
                    resultsGrid.appendChild(columnEl);
                }

                appendColumn('yes', 'Yes', voteGroups.YES);
                appendColumn('no', 'No', voteGroups.NO);
                appendColumn('abstain', 'Abstain', voteGroups.ABSTAIN);
                appendColumn('novote', 'Vote Not Recorded', voteGroups.NoVote);
                clusterMemberDetailEl.appendChild(resultsGrid);
            }

            renderClusteringNeighbors(canonicalKey);
        }

        function computeNearestNeighbors(canonicalKey, analysis, limit = 10) {
            const sourceIndex = analysis.memberIndexByKey[canonicalKey];
            if (sourceIndex === undefined) return [];

            const sourceMember = analysis.members[sourceIndex];
            const sourceRow = analysis.matrixRawWithNaN[sourceIndex];
            const neighbors = [];

            analysis.members.forEach((candidateMember, candidateIndex) => {
                if (candidateIndex === sourceIndex) return;

                const candidateRow = analysis.matrixRawWithNaN[candidateIndex];
                let overlap = 0;
                let agreements = 0;
                let sumSq = 0;

                analysis.columns.forEach((column, colIndex) => {
                    const a = sourceRow[colIndex];
                    const b = candidateRow[colIndex];
                    if (Number.isNaN(a) || Number.isNaN(b)) return;

                    overlap += 1;
                    const diff = a - b;
                    sumSq += diff * diff;

                    const sourceVote = sourceMember.rawVotesById[column.id] || 'NoVote';
                    const candidateVote = candidateMember.rawVotesById[column.id] || 'NoVote';
                    if (sourceVote === candidateVote) agreements += 1;
                });

                if (overlap === 0) {
                    neighbors.push({
                        member: candidateMember,
                        hasOverlap: false,
                        overlap: 0,
                        distance: Number.POSITIVE_INFINITY,
                        agreement: null
                    });
                    return;
                }

                neighbors.push({
                    member: candidateMember,
                    hasOverlap: true,
                    overlap,
                    distance: Math.sqrt(sumSq / overlap),
                    agreement: (agreements / overlap) * 100
                });
            });

            neighbors.sort((a, b) => {
                if (a.hasOverlap !== b.hasOverlap) return a.hasOverlap ? -1 : 1;
                if (a.hasOverlap && b.hasOverlap && a.distance !== b.distance) return a.distance - b.distance;
                return a.member.name.localeCompare(b.member.name);
            });

            return neighbors.slice(0, limit);
        }

        function renderClusteringNeighbors(canonicalKey) {
            if (!clusterNeighborsEl || !clusteringAnalysisState) return;

            const neighbors = computeNearestNeighbors(canonicalKey, clusteringAnalysisState, 10);
            if (neighbors.length === 0) {
                setPanelMessage(clusterNeighborsEl, 'No neighbors available for the selected member.');
                return;
            }

            clusterNeighborsEl.replaceChildren();
            const list = document.createElement('ol');
            list.className = 'cluster-neighbor-list';

            neighbors.forEach((neighbor, index) => {
                const item = document.createElement('li');
                const prefix =
                    `${index + 1}. ${neighbor.member.name} (${formatPrecinctLabel(neighbor.member.precinct)})`;

                if (neighbor.hasOverlap) {
                    item.textContent =
                        `${prefix} - distance ${neighbor.distance.toFixed(3)}, ` +
                        `agreement ${neighbor.agreement.toFixed(1)}% (${neighbor.overlap} shared votes)`;
                } else {
                    item.textContent = `${prefix} - agreement N/A (no overlapping votes)`;
                }

                list.appendChild(item);
            });

            clusterNeighborsEl.appendChild(list);
        }

        function renderAxisInterpretation(analysis) {
            if (!clusterAxisInfoEl) return;

            clusterAxisInfoEl.replaceChildren();

            analysis.axisInterpretation.forEach((componentInfo, index) => {
                const section = document.createElement('div');
                section.className = 'axis-component';

                const header = document.createElement('h4');
                const variance = index === 0 ? analysis.varianceExplained.pc1 : analysis.varianceExplained.pc2;
                header.textContent = `PC${componentInfo.component} (${variance.toFixed(1)}% variance)`;
                section.appendChild(header);

                const negative = document.createElement('div');
                negative.className = 'axis-direction';
                const negativeStrong = document.createElement('strong');
                negativeStrong.textContent = '\u2190 Negative: ';
                negative.appendChild(negativeStrong);
                negative.appendChild(document.createTextNode(
                    componentInfo.negative.map(item => formatVoteLabelForPanel(item.column)).join(', ')
                ));

                const positive = document.createElement('div');
                positive.className = 'axis-direction';
                const positiveStrong = document.createElement('strong');
                positiveStrong.textContent = '\u2192 Positive: ';
                positive.appendChild(positiveStrong);
                positive.appendChild(document.createTextNode(
                    componentInfo.positive.map(item => formatVoteLabelForPanel(item.column)).join(', ')
                ));

                section.appendChild(negative);
                section.appendChild(positive);
                clusterAxisInfoEl.appendChild(section);
            });
        }

        function buildPrecinctColorMap(precincts) {
            const palette = [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
                '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#393b79', '#637939',
                '#8c6d31', '#843c39', '#7b4173', '#3182bd', '#31a354', '#756bb1'
            ];
            const map = {};
            precincts.forEach((precinct, index) => {
                map[precinct] = palette[index % palette.length];
            });
            return map;
        }

        function renderClusteringPlot(analysis, colorBy) {
            if (!clusterPlotEl) return;
            if (typeof Plotly === 'undefined') {
                setClusteringStatus('Plotly is unavailable. Unable to render clustering plot.', true);
                return;
            }

            const hoverTemplate = [
                '<b>%{customdata[1]}</b>',
                'Precinct: %{customdata[2]}',
                'Sessions attended: %{customdata[3]}',
                'Votes cast: %{customdata[4]}',
                '<extra></extra>'
            ].join('<br>');

            const traces = [];

            if (colorBy === 'precinct') {
                const grouped = {};
                analysis.members.forEach(member => {
                    const precinctKey = String(member.precinct).toUpperCase();
                    if (!grouped[precinctKey]) grouped[precinctKey] = [];
                    grouped[precinctKey].push(member);
                });

                const precinctKeys = Object.keys(grouped).sort((a, b) => {
                    const pa = precinctSortValue(a);
                    const pb = precinctSortValue(b);
                    if (pa !== pb) return pa - pb;
                    return a.localeCompare(b);
                });
                const colorMap = buildPrecinctColorMap(precinctKeys);

                precinctKeys.forEach(precinctKey => {
                    const points = grouped[precinctKey];
                    traces.push({
                        type: 'scattergl',
                        mode: 'markers',
                        name: formatPrecinctLabel(precinctKey),
                        x: points.map(member => member.x),
                        y: points.map(member => member.y),
                        customdata: points.map(member => [
                            member.canonicalKey,
                            member.name,
                            member.precinct,
                            member.sessionsAttended,
                            member.votesCast
                        ]),
                        marker: {
                            size: 10,
                            color: colorMap[precinctKey]
                        },
                        hovertemplate: hoverTemplate
                    });
                });
            } else if (colorBy === 'sessions') {
                const maxSessions = Math.max(...analysis.members.map(member => member.sessionsAttended), 1);
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Members',
                    x: analysis.members.map(member => member.x),
                    y: analysis.members.map(member => member.y),
                    customdata: analysis.members.map(member => [
                        member.canonicalKey,
                        member.name,
                        member.precinct,
                        member.sessionsAttended,
                        member.votesCast
                    ]),
                    marker: {
                        size: 10,
                        color: analysis.members.map(member => member.sessionsAttended),
                        colorscale: 'Blues',
                        cmin: 1,
                        cmax: maxSessions,
                        showscale: true,
                        colorbar: { title: 'Sessions' }
                    },
                    hovertemplate: hoverTemplate
                });
            } else {
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Members',
                    x: analysis.members.map(member => member.x),
                    y: analysis.members.map(member => member.y),
                    customdata: analysis.members.map(member => [
                        member.canonicalKey,
                        member.name,
                        member.precinct,
                        member.sessionsAttended,
                        member.votesCast
                    ]),
                    marker: {
                        size: 10,
                        color: '#3498db'
                    },
                    hovertemplate: hoverTemplate
                });
            }

            if (selectedClusterMemberKey && analysis.memberIndexByKey[selectedClusterMemberKey] !== undefined) {
                const selectedMember = analysis.members[analysis.memberIndexByKey[selectedClusterMemberKey]];
                traces.push({
                    type: 'scattergl',
                    mode: 'markers',
                    name: 'Selected',
                    x: [selectedMember.x],
                    y: [selectedMember.y],
                    customdata: [[
                        selectedMember.canonicalKey,
                        selectedMember.name,
                        selectedMember.precinct,
                        selectedMember.sessionsAttended,
                        selectedMember.votesCast
                    ]],
                    marker: {
                        size: 20,
                        color: 'rgba(0,0,0,0)',
                        line: {
                            color: '#111',
                            width: 3
                        }
                    },
                    showlegend: false,
                    hovertemplate: hoverTemplate
                });
            }

            const layout = {
                margin: { t: 16, r: 20, b: 60, l: 70 },
                height: 600,
                plot_bgcolor: '#ffffff',
                paper_bgcolor: '#ffffff',
                legend: { orientation: 'h', y: -0.15 },
                xaxis: {
                    title: `Component 1 (${analysis.varianceExplained.pc1.toFixed(1)}% variance)`,
                    gridcolor: '#e9ecef',
                    zeroline: true,
                    zerolinecolor: '#ced4da'
                },
                yaxis: {
                    title: `Component 2 (${analysis.varianceExplained.pc2.toFixed(1)}% variance)`,
                    gridcolor: '#e9ecef',
                    zeroline: true,
                    zerolinecolor: '#ced4da'
                }
            };

            Plotly.react(clusterPlotEl, traces, layout, {
                responsive: true,
                displaylogo: false
            });

            if (typeof clusterPlotEl.removeAllListeners === 'function') {
                clusterPlotEl.removeAllListeners('plotly_click');
            }
            if (typeof clusterPlotEl.on === 'function') {
                clusterPlotEl.on('plotly_click', event => {
                    const point = event && event.points && event.points[0];
                    if (!point || !point.customdata) return;
                    selectedClusterMemberKey = point.customdata[0];
                    runClusteringAnalysis();
                });
            }
        }

        /****************************************************
         * TAB SWITCHING
         ****************************************************/

        function switchTab(evt, tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (evt && evt.target) evt.target.classList.add('active');

            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const targetTab = document.getElementById(tabName);
            if (targetTab) targetTab.classList.add('active');

            if (tabName === 'by-member' && members.length > 0) {
                updateMemberResults();
            }

            if (tabName === 'voter-clustering') {
                ensureClusteringDataLoaded();
            }
        }

        function enterVoteAnalyzerMode() {
            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';

            const titleEl = document.querySelector('.container h1');
            if (titleEl) titleEl.textContent = 'Brookline Vote Analyzer';

            const subtitleEl = document.querySelector('.subtitle');
            if (subtitleEl) {
                subtitleEl.textContent = 'Advanced clustering and cross-session voting pattern analysis.';
            }

            const spreadsheetControls = document.querySelector('#main-content > .controls');
            if (spreadsheetControls) spreadsheetControls.style.display = 'none';

            const tabsBar = document.querySelector('.tabs');
            if (tabsBar) tabsBar.style.display = 'none';

            const byVoteEl = document.getElementById('by-vote');
            const byMemberEl = document.getElementById('by-member');
            const clusteringEl = document.getElementById('voter-clustering');
            if (byVoteEl) byVoteEl.classList.remove('active');
            if (byMemberEl) byMemberEl.classList.remove('active');
            if (clusteringEl) clusteringEl.classList.add('active');

            ensureClusteringDataLoaded();
        }

        /****************************************************
         * INITIAL PAGE LOAD
         ****************************************************/

        window.addEventListener('DOMContentLoaded', () => {
            if (APP_MODE === 'vote-analyzer') {
                enterVoteAnalyzerMode();
                return;
            }

            const voteSelect = document.getElementById('vote-select');
            if (voteSelect) voteSelect.addEventListener('change', updateVoteResults);

            const memberSelect = document.getElementById('member-select');
            if (memberSelect) memberSelect.addEventListener('change', updateMemberResults);

            const spreadsheetSelect = document.getElementById('spreadsheet-select');
            if (spreadsheetSelect) {
                spreadsheetSelect.addEventListener('change', () => {
                    if (loadingEl) {
                        loadingEl.style.display = 'block';
                        loadingEl.textContent = 'Loading voting data...';
                    }
                    if (mainContentEl) mainContentEl.style.display = 'none';

                    votingData = null;
                    votes = [];
                    members = [];

                    loadVotingDataFromExcel();
                });
            }

            loadVotingDataFromExcel();
        });
    </script>

</body>

</html>
